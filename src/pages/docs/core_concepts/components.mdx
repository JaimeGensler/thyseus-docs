---
title: Components
---

import { Callout, Opinion } from ':ui';

# Components

A component is a unit of data that belong to an entity. An entity can have 0 or
more components and can add or remove components throughout the course of its
life. Components should be granular, self-contained "pure" data types that could
be added - or not added - to any entity. They can describe any data belonging to
an entity, such as `Transform`, `Health`, `Inventory`, `IsPlayer`, and anything
else you need!

Unlike GameObject/Component-based game architecture, **ECS components should not
contain general _systems_ behavior**. However, Thyseus allows (and encourages!)
components to contain functionality for common manipulations to their data.

## Writing Components

Components represent types of data - what more natural way to write them than as
classes? Specifically, components are classes decorated with the `@struct`
decorator:

```ts
import { struct } from 'thyseus';

@struct
class Health {
	@struct.u16 declare max: number;
	@struct.u16 declare current: number;
}
```

Using the `@struct` and `@struct.<field>` decorators, we've defined a `Health`
component with two fields - the `max` and the `current` health of the entity it
belongs to. The `@struct.u16` decorator means that the property contains a `u16`
value (short for _unsigned 16-bit integer_).

### Methods

If we wanted to change the values for an instance, we could directly mutate them
with `health.current = 5` and `health.max = 10`. In this particular case,
though, there's nothing stopping `current` from exceeding `max` - something we
probably never want! This is a great case for methods:

```ts {8-11,13-18}
import { struct } from 'thyseus';

@struct
class Health {
	@struct.u16 declare max: number;
	@struct.u16 declare current: number;

	heal(amount: number) {
		// Clamp to max!
		this.current = Math.min(this.max, this.current + amount);
	}

	takeDamage(amount: number): boolean {
		// Clamp to 0 to prevent integer underflow
		this.current = Math.max(0, this.current - ammount);
		// Return a boolean indicating if this entity died!
		return this.current === 0;
	}
}
```

Great! Now instead of directly modifying `max` and `current`, we can just use
the `heal()` and `takeDamage()` methods. This helps to keep our code dry, easily
testable, and keeps the common functionality of `Health` in one place.

Note that the methods here describe operations on the data itself, and does not
contain generalized behavior like an `update()` method. This `Health` component
could be reasonably re-used by numerous, vastly different applications, because
_how_ this component will be used is left to systems!

### Component Field Types

<Callout type="note">
	For components to work correctly, component classes **must** be decorated
	with `@struct`, and all properties **must** be decorated with a property
	decorator!
</Callout>

Components allow granular control of your numeric types. While Javascript
numbers must behave as
[double precision 64-bit floating point numbers](https://en.wikipedia.org/wiki/Double-precision_floating-point_format),
Thyseus allows you to declare more specifically what _kind_ of number a property
is. The primitive types are all properties of `@struct`, and are listed below:

| Name | Description                  | Size (bytes) | JS Type |
| ---- | ---------------------------- | ------------ | ------- |
| u8   | Unsigned 8-bit integer       | 1            | number  |
| u16  | Unsigned 16-bit integer      | 2            | number  |
| u32  | Unsigned 32-bit integer      | 4            | number  |
| u64  | Unsigned 64-bit integer      | 8            | bigint  |
| i8   | Signed 8-bit integer         | 1            | number  |
| i16  | Signed 16-bit integer        | 2            | number  |
| i32  | Signed 32-bit integer        | 4            | number  |
| i64  | Signed 64-bit integer        | 8            | bigint  |
| f32  | 32-bit Floating Point number | 4            | number  |
| f64  | 64-bit Floating Point number | 8            | number  |
| bool | Boolean (`true`/`false`)     | 1            | boolean |

If you're not used to working with different numeric types, don't worry -
`@struct.f64` works like the Javascript numbers you're used to, and is a fine
choice getting started! It just may not always be the best fit.

## Constructors

You may provide a constructor for your structs, provided you pass `this` to the
`initStruct` function first - similar to calling `super()` in subclasses.

```ts {8-14}
import { struct, initStruct } from 'thyseus';

@struct
class Health {
	@struct.u16 declare max: number;
	@struct.u16 declare current: number;

	constructor(max = 100, current = max) {
		// You must call initStruct before accessing fields!
		initStruct(this);

		this.max = max;
		this.current = current;
	}
}
```

**Constructors may not have any required arguments**. You can use this feature
to set default values of components when adding them to entities - for example,
in the above case, if you add the `Health` component to an entity without
specifying a `current` and `max` value, both will be set to 100.

### Avoiding Construction

In general, it is best to **avoid constructing components yourself** (e.g.
`new Health()`).

Thyseus takes responsibility for the lifetime of objects that it creates;
however, **if you call a constructor yourself, you become responsible for
cleaning up that struct instance when it is no longer used.** Instances you own
must call the `dropStruct()` function when they go out of scope. If you need a
local component instance, consider using
[system resources](/docs/system_parameters/system_resources).

<Opinion type="negative" title="Bad (will cause a memory leak)">
	```ts {4}
	import { Position } from './components';

    function spawnEntities(commands: Commands) {
    	commands.spawn().add(new Position(1, 2, 3));
    }
    ```

</Opinion>

<Opinion type="positive" title="Good">
	```ts
	import { dropStruct } from 'thyseus';
	import { Position } from './components';

    function spawnEntities(commands: Commands) {
    	const position = new Position(1, 2, 3);
    	commands.spawn().add(position);
    	dropStruct(position);
    }
    ```

</Opinion>

<Opinion type="positive" title="Best">
	```ts {3}
	import { Position } from './components'

    function spawnEntities(
    	commands: Commands,
    	pos: SystemRes<Position>
    ) {
    	pos.set(1, 2, 3);
    	commands.spawn().add(pos);
    	// Thyseus owns pos, so you don't need to drop it here
    }
    ```

</Opinion>

## Non-primitive fields

While primitives will work for many cases, sometimes you need more complex
types. Thyseus provides three decorators for complex types out of the box.

### `@struct.string`

```ts
@struct
class MyStruct {
	@struct.string declare str: string;
}
```

The `@struct.string` decorator looks like a primitive decorator, but is
considered complex because dynamically sized strings require dynamic allocation.
You can get and set Javascript strings as you'd expect with this decorator!

### `@struct.array()`

```ts
@struct
class MyStruct {
	@struct.array({ type: 'u8', length: 4 }) declare arr: Uint8Array;
	@struct.array({ type: 'f32', length: 16 }) declare str2: Float32Array;
}
```

This decorator allows you to specify a typed array as a property. It accepts an
options object containing `{ type: PrimitiveType, length: number}`. Type is one
of the numeric primitive types listed above (`'u8'`, `u16`, etc.) and length is
the number of elements the array contains.

### `@struct.substruct()`

```ts
@struct
class RGB {
	@struct.u8 declare r: number;
	@struct.u8 declare g: number;
	@struct.u8 declare b: number;
}

@struct
class RGBA {
	@struct.substruct(RGB) declare rgb: RGB;
	@struct.u8 declare a: number;
}
```

This decorator allows you to nest structs within structs. It accepts a struct
class to be a member of a struct, and will return an instance of that struct.

## Extending Structs

For the most part, `@struct`-decorated classes will work just like any other
Javascript class. However, **extending structs only works so long as you do not
add additional fields**. If you'd like to extend a component with new fields,
you'll need to instead use the `@struct.substruct` decorator.

<Opinion type="negative" title="Bad, will not work as expected">
	```ts
	@struct
	class Vec2 {
		@struct.f64 declare x: number;
		@struct.f64 declare y: number;
	}

    @struct
    class Vec3 extends Vec2 {
    	// We cannot extend structs with new fields!
    	@struct.f64 declare z: number;
    }
    ```

</Opinion>

<Opinion type="positive" title="Good">
	```ts
	@struct
	class Vec2 {
		@struct.f64 declare x: number;
		@struct.f64 declare y: number;
	}

    class Vec3 {
    	@struct.substruct(Vec2) declare vec2: Vec2;
    	@struct.f64 declare z: number;

    	get x() {
    		return this.vec2.x;
    	}
    	set x(value: number) {
    		this.vec2.x = value;
    	}
    	get y() {
    		return this.vec2.y;
    	}
    	set y(value: number) {
    		this.vec2.y = value;
    	}
    }
    ```

</Opinion>

<Opinion type="positive" title="Also good">
	```ts
	import { struct } from 'thyseus';

    @struct
    class Vec3 {
    	@struct.f64 declare x: number;
    	@struct.f64 declare y: number;
    	@struct.f64 declare z: number;
    }

    // These don't add additional fields, and so work totally fine!
    class Position extends Vec3 {}
    class Velocity extends Vec3 {}
    ```

</Opinion>

## Zero-Sized Types (ZSTs)

In some cases, you may want to add a "tag" to entities (e.g., `IsPlayer`) but
have no additional data associated with that component. In these cases, you can
use a **zero-sized type**. As the name implies, these are structs that require
no space when stored.

```ts
@struct
class IsPlayer {}
```

ZSTs can be added to and removed from entities just like any other component!
The only difference between a ZST and a sized component is that ZSTs cannot be
queried for directly, as Thyseus never actually constructs ZST instances. Fret
not - they're still perfectly useable in queries!
