---
title: v0.15 Release
date: '2023-12-01'
author: jaime
---

# v0.16 Released

In the last blog post I mentioned that there were no particularly large plans
for the near future - so naturally, within a week I was rethinking Thyseus's
fundamental architecture. I spent some time working out the weakpoints as well
as what causes them, challening many of the assumptions we've made along the
way. After all this time, I'm excited to announce

Such a huge change comes with many wins - for getting started, performance,
removing gotchas, and contributing to (or reaching into) the library. It's also
a huge win for bundle size, which has shrunk by over 40%! This drop is an even
bigger win when considering parts of the library are tree-shakeable in ways they
weren't before, and some transformation emit has been reduced considerably.

Fear not - though there are breaking changes ahead, most of them should be
fairly painless. Let's dive in!

## Weakpoints & Internal Changes

So much of the what's changed has cross-cutting concerns that it's difficult to
neatly isolate them into areas of change. As a result, the first part of this
release blog will discuss some weakpoints and the internal changes made to
address them, and later discuss migration guide. Feel free to skip straight to
migration if you'd like!

To start with weakpoints:

-   Multithreading is inflexible and slow (explored in more depth later).
-   The amount of code shipped with all consumers of Thyseus is considerable,
    while much of it benefits only a subset of users.
-   Async patterns within systems are really tricky.
-   Development iteration is slow.
-   Adding/modifying tests is difficult.
-   Integration with third-party libraries is difficult.

isolating new features and breaking changes is difficult has too many
cross-dependencies to neatly isolate new features and breaking iterations.

### Threads

For some time now, I feel Thyseus has failed to truly deliver on one of it's big
selling points - multithreading. While we have a half-measure solution, it has
historically been buggy, inflexible, and slow. Writing a sound & performant
smart scheduler is hard, but more to the point it's become apparent that it's
not even what most people want from a JS multithreading solution.

The far more common use case is a dedicated render or physics thread, or a way
to push some non-essential tasks somewhere else.

With this in mind, I've considered what a solution that would meet real needs
would look like. This new solution would never have been possible without
invaluable input from [mcd]() and [kayh]() - many thanks to both of them! The
new thread solution:

## Migration

### Schedules & World Events

The model for schedules and world start have been slightly changed. The world
now accepts event listeners with the typical `addEventListener` and
`removeEventListener`. Rathern than executing a special schedule,
`world.start()` emits a `"start"` event - you can register a callback to specify
what should happen on world start, likely similar to your past start system.
There's a similar `world.stop()` which can be used for any teardown you need it
to.

`DefaultSchedule` and `StartSchedule` have been removed. Instead, Thyseus
provides a `Schedule` class which holds systems and their arguments and runs
them. `WorldBuilder.addSystem()` adds systems to this schedule - if you'd like
to define your own schedule, you can simply extend this schedule. This pattern
allows you to define more custom system execution when you need.

# BREAK

---

## Components Reconsidered

While a lot of progress has been made in the past few versions, components still
have a few gotchas. The pain points with components are primarily a result of
**serialization** and **pooling**. Since the first release, we've leaned into
binary data backing and object pooling - th theory for was it'd keep memory
usage lower and allow runtimes to generate more optimal bytecode.

This forgets that Javascript runtimes are really, _really_ good at what they
do - so good, in fact, that it's actually faster to just iterate a list of
objects. All Thyseus needs to do is densely pack data in single-type arrays; the
VM can handle the rest.

What does this mean for you?

-   `@struct` and the binary numeric data types (`u8`, `u16`, etc.) have been
    removed. The transformer does not emit any component-related code.
-   **Any class can be used as a component, and classes can have any fields**.
    -   Components must still be classes to determine their type.
-   Component constructors may have required arguments.
-   Components must be added to entities with `.add()` and not `.addType()`.
-   Data is not copied when adding components or events - objects are treated
    uniquely.
-   Tag components (ZSTs) can be created by extending the exported `Tag` class.
-   `Promise.then()` and other callbacks will refer to the objects you think
    they will in query/event iteration.

The exact gains from this vary by runtime and object shape, but in general it
should be at least as performant, usually more, and removes any potential
surprises when handling components.

## Threads Reconsidered

One of Thyseus' big selling points is the fact that it handles multithreading
for you. That's _kind of_ true - we've included a smart scheduler as part of
Thyseus since v0.1, only requiring a change in config to take advantage of
parallelism. However, this solution has historically been buggy, inflexible,
and - worst of all - **slow**.

Turns out writing a sound & performant smart scheduler is hard. Apart from this,
it's become apparent that it's not even what most people want from a JS
multithreading solution. The far more common use case is a dedicated render or
physics thread, or a way to push some non-essential tasks somewhere else.

With this in mind, I've considered what a solution that would meet real needs
would look like. This new solution would never have been possible without
invaluable input from [mcd]() and [kayh]() - many thanks to both of them! The
new thread solution:

-   Is **as safe** as the previous solution
-   Is much more atomic
-   Is much lighter weight
-   Makes it possible for bundlers to only include necessary code for each
    thread (_including the main thread_)
-   Can be tree-shaken out for those who aren't using concurrency, or those who
    would like to roll their own concurrency solution
-   Allows node users to take advantage of threads

### A New API

The new threading API empowers you to write workers just like your typical web
worker code with none of the boilerplate and all of the type-safety. Let's look
at a simple example:

```ts filename="myThread.ts"
'use thread';

export function adder(a: number, b: number) {
	return a + b;
}
```

Here we've specified the module is a thread with `'use thread';`. This sort of
statement is likely familiar to those who work in the broader Javascript
ecosystem, with `'use strict'` and NextJS's `'use client'` and `'use server'`.
This statement is expanded by the transformer into an event handler that allows
the module to receive events posted from the main thread. We also `export` the
function we want exposed to the main thread - only exported fields are public!

How does one access threads? Just like any other data or functionality - a
system parameter!

```ts filename="myMainThreadFile.ts"
async function systemThatUsesThreads(
	thread: Thread<typeof import('./myThread'))>
) {
	const result = await thread.run('adder', 1, 1);
	console.log(result); // -> 2!
}
```

In our system, we declare that we'd like to access the provided module as a
thread. We're given a wrapper (`Thread`) over the worker which provides us with
strong typesafety guarantees. We only exposed `adder`, so that's the only string
`Thread` will recognize here, and it knows the number and types of arguments as
well as the return! As worker code is inherently async, `thread.run()` returns a
promise that resolves to whatever value was returned by the function called in
the other thread.

Of course, you aren't required to immediately await this promise in the system -
you can choose to handle it however you like. There's also no problem with
calling `thread.run()` again before the Promise has resolved - queue up as many
tasks as you need run! Arguments and return values are structured-cloned when
sent between threads, so be aware that only structured-cloneable values can be
sent across threads.

There may be cases where you may want to set a value in a worker from the main
thread - or maybe you'd like to actually [transfer]() an object. We provide two
primitives for this as well. Simply export mutable bindings from the worker...

```ts
'use thread';

export let canvas: OffscreenCanvas;
export let width: number;
export let height: number;
```

...and `send()` or `transfer()` their new values from the main thread!

```ts filename="myMainThreadFile.ts"
async function someSystem(
	thread: Thread<typeof import('./myThread'))>
) {
	const width = window.innerWidth;
	const height = window.innerHeight;
	await thread.transfer('canvas', new OffscreenCanvas(width, height));
	await thread.send('width', width);
	await thread.send('height', height);
}
```

Here we've transferred an OffscreenCanvas object to the thread and set the
`canvas` variable to it, as well as setting the `width` and `height`. Remember
that these must be `let` statements to be reassigned.

`'use thread'` does _not_ have to appear at the top of a module - for example,
you could wrap it in `if (typeof document !== undefined)` if you also import the
thread module on the main thread and want to avoid setting up event listeners
that won't be used.

Lastly, we've added a new piece of config - `createWorker(url: string): Worker`.
This config accepts a url for the worker and should return a new worker-like
object. This does _not_ have to be identical to `Worker` as seen in browsers -
it only needs to have methods for `addEventListener()`, `postMessage()`, and
`terminate()`.

### The Future

This is very much a first iteration of threads. While these primitives are in
solid shape, there's a lot of room to grow from this foundation, including task
pools, allowing systems to be called in threads, and finding ways to gracefully
prevent the total thread count exceeding `navigator.hardwareConcurrency`.

## Removal of `run()`

`run()` was only necessary for smart scheduling, allowing us to eek out as much
parallelism as possible while enabling consumers to enforce ordering of systems.
However, most consumers likely want a strict, consistent ordering of systems
(which `run()` did _not_ guarantee), and the new concurrency model requires
thread usage to be explicit anyway. As a result, **`run()` has been removed and
systems will execute in the order they are added**. This is identical to past
behavior if you were only using single-threaded execution.

## Mutable Default

With the changes to the threading model, it was also time to reconsider
mutability as well. If you only ever run code on one thread, the benefits of
readonly default are more organizational than performance oriented. Wrapping
types in `Mut` is also somewhat counterintuitive as typically mutability is the
language default and you must specify `Readonly`. This is especially noticeable
with queries, where the accessors you specify in `Query<A>` aren't exactly what
you get in iterations.

For 0.16, **`Mut` has been removed**. You may wrap your types in `Readonly` if/
when you'd like - it's usually a good idea, but not mandatory. We also provide a
stricter `Read<T>` type; Typescript's provided `Readonly` does not enforce
nested objects to be readonly and allows methods that self-modify - `Read<T>`
guarantees this strictness. `Read` and `Readonly` are treated identically in
terms of transformation. Altogether, these changes should allow your apps to be
safer than before!

## Schedules & World Events

The model for schedules and world start have been slightly changed. The world
now accepts event listeners with `addEventListener` (and `removeEventListener`).
Calling `world.start()` emits a `start()` event - you can register a callback to
specify what should happen on world start, likely similar to your past start
system. There's a similar `world.stop()` which can be used for any teardown you
need it to.

`DefaultSchedule` and `StartSchedule` have been removed. Instead, Thyseus
provides a `Schedule` class which holds systems and their arguments and runs
them. `WorldBuilder.addSystem()` adds systems to this schedule - if you'd like
to define your own schedule, you can simply extend this schedule. This pattern
allows you to define more custom system execution when you need.

## Other Changes

### Entity Liveliness

As components are no longer pooled, it's safe to hold on to references of
`Entity` components. To make working with entities easier, an `isAlive` property
has been added to `Entity`; once an entity has been despawned (_after_
`applyCommands` runs), it will be `false`. `Entity` components are never reused
so once `isAlive` is false you should drop references to the object.

### Removal of Registration

The need for registering types before building a world has been lifted -
resources and components can be added at runtime. In the future, we'll add new
APIs to make it easier to take advantage of runtime components and dynamically
adding systems.

### `Memory` Removed

When custom memory allocation was first added, it provided significant
flexibility in what could be achieved with threads, only requiring most data to
be sent across threads once. This design was incredibly powerful, but it also
adds a _significant_ amount of code that must ship with all Thyseus consumers,
while only benefiting those using concurrency. It was also the source of most of
our complexity - most bugs that have been reported in Thyseus since the
introduction of `Memory` were caused by it. Worse, it also put us on the hook
for allocation-related performance. With many of the assumptions about the needs
of threads challenged, we were able to fully remove the `Memory` API.

### Simplified System Parameters

The changes to threads mean that system parameters can be much simpler - in
fact, you only need to provide `intoArgument` for your own system parameters
now. These will likely be expanded once again in the future as the threading API
matures, but for now we wanted to remove the dead weight.

### World Config Changes

With the changes to threads and the removal of `Memory`, most of the options
available in `config` have been made obsolete. The aforementioned
`createWorker()` config is the only remaining config at the moment!

### Better Inline Documentation

Quite a bit of inline documentation has been added to different classes and
their methods - it should be easier than ever to understand what Thyseus can do
from the comfort of your editor! As always, we're continuing to update and
improve the docs on the site as well.
