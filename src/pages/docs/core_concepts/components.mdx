---
title: Components
---

import { Callout, Opinion } from ':ui';

# Components

A component is a unit of data that belong to an entity. An entity can have 0 or
more components and can add or remove components throughout the course of its
life. Components should be granular, self-contained "pure" data types that could
be added - or not added - to any entity. They can describe any data belonging to
an entity, such as `Transform`, `Health`, `Inventory`, `IsPlayer`, and anything
else you need!

Unlike GameObject/Component-based game architecture, **ECS components should not
contain general _systems_ behavior**. However, Thyseus encourages components to
contain functionality for common manipulations to their data.

## Writing Components

Components are classes decorated with the `@struct` decorator:

```ts
import { struct } from 'thyseus';

@struct
class Health {
	max: number = 0;
	current: number = 0;
}
```

The above defines a `Health` component with two fields - the `max` and `current`
health of the entity it belongs to. We've also added initializers for the fields
and given them an **explicit** type - field types in structs must be explicit!

### Types

Component fields must belong to a subset of types. The primitives:

| Name    | Description                  | Size (bytes) | Alias  |
| ------- | ---------------------------- | ------------ | ------ |
| number  | Identical to `f64`           | 8            | -      |
| boolean | `true` or `false`            | 1            | -      |
| u8      | Unsigned 8-bit integer       | 1            | number |
| u16     | Unsigned 16-bit integer      | 2            | number |
| u32     | Unsigned 32-bit integer      | 4            | number |
| u64     | Unsigned 64-bit integer      | 8            | bigint |
| i8      | Signed 8-bit integer         | 1            | number |
| i16     | Signed 16-bit integer        | 2            | number |
| i32     | Signed 32-bit integer        | 4            | number |
| i64     | Signed 64-bit integer        | 8            | bigint |
| f32     | 32-bit Floating Point number | 4            | number |
| f64     | 64-bit Floating Point number | 8            | number |

`number` and `boolean` work as expected, but as shown components also allow
other numeric types. If you're not used to working with multiple numeric types,
don't worry; `number` is a fine choice getting started, it just may not always
be the best fit!

<Callout type="note">
	When handling struct instances, numbers are typical double-precision
	Javascript numbers. They are casted into their narrow type during
	serialization, and will be observable after deserialization.
</Callout>

A more appropriate choice for our `Health` component might be `u32`:

```ts
import { struct } from 'thyseus';

@struct
class Health {
	max: u32 = 0;
	current: u32 = 0;
}
```

More complex types are also permitted in structs, including strings, tuples
(fixed-size same-type arrays) and _other structs_.

```ts
@struct
class Player {
	name: string;
	color: [u8, u8, u8, u8]; // [r, g, b, a]
	id: Entity; // The entity component
}
```

### Methods

If we wanted to change the values for an instance, we could directly mutate them
with `health.current = 5` and `health.max = 10`. In this particular case,
though, there's nothing stopping `current` from exceeding `max` - something we
probably never want! This is a great case for methods:

```ts {8-11,13-18}
import { struct } from 'thyseus';

@struct
class Health {
	#max: u32 = 0;
	#current: u32 = 0;

	heal(amount: number) {
		// Clamp to max!
		this.#current = Math.min(this.#max, this.#current + amount);
	}

	takeDamage(amount: number): boolean {
		// Clamp to 0 to prevent integer underflow
		this.#current = Math.max(0, this.#current - amount);
		// Return a boolean indicating if this entity died!
		return this.#current === 0;
	}
}
```

Great! Now instead of directly modifying `max` and `current`, we can just use
the `heal()` and `takeDamage()` methods. Additionally, we've converted the
fields to be `#` private, so that consumers must use methods to interact with
this component. This helps to keep our code dry and easily testable, while
keeping the core functionality of `Health` in one place.

### Constructors

You can provide constructors for your structs as well; the only requirement is
that if you're using a struct as a component, **the constructor may not have any
_required_ arguments**. If you're simply using it as a type for another struct,
constructors may have required arguments.

```ts {8-11}
import { struct } from 'thyseus';

@struct
class Health {
	max: u32;
	current: u32;

	constructor(max = 100, current = max) {
		this.max = max;
		this.current = current;
	}
}
```

Constructors can also be used to set default values - in the above case, if you
adding the `Health` component by type will set both `current` and `max` to 100.

### Inheritance

Like any other Javascript class, you may also extend structs.

```ts
@struct
class Vec3 {
	x: f64;
	y: f64;
	z: f64;
}

class Position extends Vec3 {}
class Velocity extends Vec3 {}
```

If you'd like to add fields to the extended class, just make sure to decorate
the class again!

```ts
@struct
class Vec2 {
	x: f64;
	y: f64;
}

@struct
class Vec3 extends Vec2 {
	z: f64;
}

@struct
class Vec4 extends Vec3 {
	w: f64;
}
```

## Zero-Sized Types (ZSTs)

In some cases, you may want to add a "tag" to entities (e.g., `IsPlayer`) but
have no additional data associated with that component. In these cases, you can
use a **zero-sized type**. As the name implies, these are structs that require
no space when stored.

```ts
@struct
class IsPlayer {}
```

ZSTs can be added to and removed from entities just like any other component!
The only difference between a ZST and a sized component is that ZSTs cannot be
queried for directly, as Thyseus never actually constructs ZST instances. Fret
not - they're still perfectly useable in queries!
