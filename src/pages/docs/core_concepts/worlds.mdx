---
title: Worlds
---

import { Callout } from ':ui';

# Worlds

Worlds contain your entities and components, and are responsible for executing
systems. Every world is independent and self-contained; systems and types can be
used by multiple worlds, but data belongs to a single world.

## Adding Systems

Worlds start with `World.new()`, which returns a `WorldBuilder`. The
`WorldBuilder` is responsible for registering any systems you may want to start
out.

```ts
import { World } from 'thyseus';

const myWorldBuilder = World.new();
```

And let's add a system:

```ts {2,4}
import { World } from 'thyseus';
import { Inventory, IsPlayer } from './components';

function inventorySystem(query: Query<Inventory, With<IsPlayer>>) {}

const myWorldBuilder = World.new().addSystems(inventorySystem);
```

Most methods on `WorldBuilder`s return the `WorldBuilder` itself, so they can be
chained. Let's add a few more systems!

```ts {5-7}
import { World } from 'thyseus';
import { move, draw, handleInput } from './systems';

const myWorldBuilder = World.new()
	.addSystems(move)
	.addSystems(draw)
	.addSystems(handleInput);
```

Of course, it's called `addSystems` for a reason:

{/* prettier-ignore */}
```ts {5}
import { World } from 'thyseus';
import { move, draw, handleInput } from './systems';

const myWorldBuilder = World.new()
	.addSystems(move, draw, handleInput);
```

## Building A World

When you've added all the systems you'd like, you can build your world and start
executing systems. We can use the `build()` method for this, which returns a
promise that resolves with your completed world. Let's try it now with a system
that just calls `console.log`:

{/* prettier-ignore */}
```ts {9}
import { World } from 'thyseus';

function helloSystem() {
	console.log('Hello, world!')
}

const myWorld = await World.new()
	.addSystems(helloSystem)
	.build();
```

<Callout type="note">
	Top-level await is a convenient way to handle the promise returned by
	`build()` - especially when starting out - but is not required.
</Callout>

Cool, but just building a world doesn't start your systems. Let's set up a loop
to call our system!

{/* prettier-ignore */}
```ts {11-15}
import { World, DefaultSchedule } from 'thyseus';

function helloSystem() {
	console.log('Hello, world!')
}

const myWorld = await World.new()
	.addSystems(helloSystem)
	.build();

async function loop() {
	await myWorld.runSchedule(DefaultSchedule)
	requestAnimationFrame(loop)
}
loop()
```

Here, we're using the `runSchedule` method - we'll cover schedules next, but for
now all you need to know is systems are added to the `DefaultSchedule` when you
use `addSystems`, and calling `runSchedule` runs all systems in a schedule.

If you look in your browser's log, you should see a whole lot of
`"Hello, world!"`s!

## Schedules

Worlds can contain multiple groups of systems called **schedules**. Schedules
run all the systems they contain together before execution of other schedules
may occur. However, schedules may contain systems that execute _other_
schedules.

Schedules have a number of different uses - they can be used to create a group
of systems that only runs when your app starts, or when tearing down, or systems
that need to run at a fixed rate!

By default, Thyseus provides two schedules - the `DefaultSchedule`, which
systems are added to when calling `addSystems`, and the `StartSchedule`.

### `StartSchedule`

The `StartSchedule` is intended to control the execution of all other schedules.
It is run when `world.start()` is called. Let's rewrite the above example using
this:

{/* prettier-ignore */}
```ts {11-15}
import { World, DefaultSchedule, StartSchedule } from 'thyseus';

function helloSystem() {
	console.log('Hello, world!');
}

function start(world: World) {
	async function loop() {
		await world.runSchedule(DefaultSchedule);
		requestAnimationFrame(loop);
	}
	loop();
}

const myWorld = await World.new()
	.addSystems(helloSystem)
	.addSystemsToSchedule(StartSchedule, start)
	.build();

myWorld.start();
```

This is essentially the same as the previous example, but now we've localized
all our startup logic to `start`. Using `world.start()` comes with the added
bonus that it can safely be called from any thread (unlike `world.runSchedule`,
which must only be called from the main thread).

## Plugins

Plugins are simply functions that accept a `WorldBuilder` instance and register
systems and types on that `WorldBuilder`. Plugins give you the flexibility to
change the implementation details of a piece of functionality without changing
the external API.

```ts
import { World } from 'thyseus';
import {
	applyForces,
	detectCollisions,
	resolveCollisions,
} from './physicsSystems';

const FixedUpdateSchedule = Symbol();
function physicsPlugin(builder: WorldBuilder) {
	builder.addSystems(
		FixedUpdateSchedule,
		applyForces,
		detectCollisions,
		resolveCollisions,
	);
}

const world = await World.new().addPlugin(physicsPlugin).build();
```
