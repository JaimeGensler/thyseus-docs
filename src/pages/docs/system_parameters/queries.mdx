---
title: Queries
---

import { Callout } from ':ui';

# Queries

Queries allow you to find all entities that have a specific collection of
components. They're one of the most fundamental building blocks of any ECS and
are the primary way you'll access component data. In Thyseus, queries are system
parameters, so systems can specify as many queries as they need.

## Accessing Data

To query for a specific component, you can provide it as the first generic of
the `Query` type. Your system will receive a query as an argument that can be
iterated over:

```ts
import { struct } from 'thyseus';
import { Health } from './components';

export function querySystem(query: Query<Health>) {
	for (const health of query) {
		console.log(`${health.current}/${health.max}`);
	}
}
```

Here, we're querying for all entities with the `Health` component. In our system
we iterate over each of those entities and log the current and max values; the
yielded `health` value will be an instance of `Health`.

<Callout type="warn">
	Thyseus re-uses component instances during iteration for performance
	reasons, so **you should not grab and hold a reference to it**.
</Callout>

If you'd like to access multiple components in the same query, you can use a
tuple:

```ts {4}
import { struct } from 'thyseus';
import { Position, Velocity } from './components';

export function queryABSystem(query: Query<[Position, Velocity]>) {
	for (const [pos, vel] of query) {
		console.log(pos, vel);
	}
}
```

In this case, the query will yield `[Position, Velocity]` tuples. You can use
tuples of any size to specify the components you need, but you cannot nest
tuples.

If you're copying these examples locally, you may have noticed that both `pos`
and `vel` are typed as `readonly`. **By default, queries only provide `readonly`
access to components.** Of course, data that can only ever be read is of very
limited use to us.

### Writing Data

Mutable component data is as easy as wrapping your components in `Mut`:

```ts
import { Position, Velocity } from './components';

export function moveSystem(query: Query<[Mut<Position>, Velocity]>) {
	// Now position is mutable, but velocity is still readonly.
	for (const [pos, vel] of query) {
		pos.x += vel.x;
		pos.y += vel.y;
		pos.z += vel.z;
	}
}
```

Queries can have as many mutable components as needed! While it may be tempting
to make everything mutable _just in case_, you should prefer immutability when
possible.

<Callout type="warn">
	At the moment, Thyseus does not throw an error if you write data that you've
	requested readonly. **This will likely change in the future**. For now,
	Typescript will help prevent these mistakes!
</Callout>

## Filters

Queries also allow you to specify that entities must have or _not_ have specific
components without needing access to those components. These are known as
**_filters_**. Filters are the second argument of the `Query()` descriptor
creator, and must always be wrapped in some filter specifier.

### With

As the name implies, this filter requires that entities have a specific
component. If they do not, the query will fail to match. `With` filters are
particularly useful for zero-sized components, which you may use to "tag"
entities.

```ts
function yourSystem(query: Query<A, With<B>>) {
	// Query iteration is the same as if there was no filter, but it's
	// guaranteed that all matched entities have both A and B
	for (const a of query) {
	}
}
```

You can pass either a single component to `With`, or an array of components if
you want to require multiple (an "And" clause):

```ts
// Matched Entities will have A, B, and C
// This is identical to Query(A, [With(B), With(C)])
function yourSystem(query: Query<A, With<[B, C]>>) {}
```

### Without

The opposite of With, `Without` requires that queried entities do not have
specific components.

```ts
// All matched entities have A, and do NOT have B
function yourSystem(query: Query<A, Without<B>>) {}
```

### Or

`Or` filters allow more complex query logic, where entities may satisfy either
condition provided in order to match a query. `Or` can only accept two
arguments, but you may nest them as deeply as you need. The provided arguments
must be valid filters - `With`, `Without`, `Or`, or some tuple ("And") of those
items.

```ts
// All matched entities have A, and have either B or C
function yourSystem(query: Query<A, Or<With<B>, With<C>>>) {}
```

### Filter Simplification & Impossible Queries

When queries are created, they will look for impossible conditions and remove
them from the list of potential match patterns in a "simplification" process.
After simplification, if there are no potential match patterns, you have created
an impossible query and an error will be thrown. For example:

```ts
function yourSystem(query: Query<A, Without<A>>) {}
```

The above query requires an entity to both have A and to _not_ have A. Because
there is no possible way for this query to match entities, an error will be
thrown when the query is built.

Let's consider a slightly more complex query that simplifies but does not throw:

{/* prettier-ignore */}
```ts
function yourSystem(query: Query<
	_,
	[
		Or<With<A>, With<B>>,
		Or<Without<A>, Without<B>>
	]
>) {}
```

Strictly speaking, there are four possible ways an entity could match this
query:

-   (A && !A) - The entity has **A** and does not have **A**.
-   (A && !B) - The entity has **A** and does not have **B**.
-   (B && !A) - The entity has **B** and does not have **A**.
-   (B && !B) - The entity has **B** and does not have **B**.

Conditions 1 and 4 are impossible and so will be removed from the query matching
process, leaving us with two possible conditions to check. In this case, no
error will be thrown. In general, it is suggested that you write queries as
clearly as possible so as not to take advantage of simplification, but this
behavior is available if for whatever reason it is the best/only way to write a
query.
