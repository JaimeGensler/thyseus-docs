# v0.16 Released

In the last blog post I mentioned that there were no particularly large plans
for the near future - so naturally, within a week I was rethinking the
fundamental architecture of Thyseus. After much challenging of the assumptions
at the core of the library, this update is the biggest change to the internal
design yet; it's practically Thyseus 2.0!

Of course such a huge change comes with many wins - for performance, getting
started, removing gotchas, and contributing to (or reaching into) the library.
It's also a huge win for bundle size, which has shrunk by over 30%! This huge
drop is an even bigger win when considering parts of the library are
tree-shakeable in ways they weren't before, and some transformation emit has
been removed.

Fear not - though there are breaking changes ahead, most of them should be
fairly painless. Let's dive in!

## Components Reconsidered

Components being a core aspect of an ECS, working with them needs to be painless
and straightforward. A lot of progress has been made in the past few versions,
but there's still a few gotchas. When digging into it, the real pain points with
components lies with **serialization** and **pooling**. We've leaned into binary
data backing and object pooling since the very first release - individual
instances are re-used and Thyseus handles the underlying data when iterating
components. The reasoning for this was to keep memory usage low and to work with
binary types in the hopes it'd be more performant.

This forgets that Javascript runtimes are really, _really_ good at what they
do - so good, in fact, that for an API like Thyseus's it's actually faster to
just instantiate a bunch of objects and iterate those. As long as data is
densely packed in single-type arrays and object shapes are stable, the VM can
and will work miracles. The exact gains from this vary by browser and object
shape, but in general it should be at least as performant, often more, and
dramatically simplifies library internals.

What does this mean for you?

-   `@struct` and the binary numeric data types (`u8`, `u16`, etc.) have been
    removed. The transformer does not emit any component-related code.
-   **Any class can be used as a component, and classes can have any fields**.
    Components must still be classes to determine their type.
-   Component constructors may have required arguments.
-   Sized components must be added to entities with `.add()` and not
    `.addType()`.
-   Tag components (ZSTs) can be created by extending the exported `Tag` class.
-   `Promise.then()` and other callbacks will refer to the objects you think
    they will in query/event iteration.

## Threads Reconsidered

One of Thyseus' big selling points is the fact that it handles multithreading
for you. That's _kind of_ true - we've included a smart scheduler as part of
Thyseus since v0.1, only requiring a change in config to take advantage of
parallelism. However, this solution has historically been buggy, inflexible,
and - worst of all - **_slow_**.

Turns out writing a sound & performant smart scheduler is _really_ hard. Apart
from this, it's become apparent that it's not even what most people want from a
JS multithreading solution. The far more common use case is a dedicated render
or physics thread, or a way to push some non-essential tasks somewhere else.

With this in mind, I wrote up a design doc and considered what a solution that
would meet real needs would look like. This new solution would never have been
possible without invaluable input from [mcd]() and [kayh]() - many thanks to
both of them! The new thread solution:

-   Is **as safe** as the previous solution
-   Is much more atomic
-   Is much lighter weight
-   Makes it possible for bundlers to only include necessary code for each
    thread (_including the main thread_)
-   Can be tree-shaken out for those who aren't using concurrency, or those who
    would like to roll their own concurrency solution
-   Allows node users to take advantage of threads

### A New API

The new threading API empowers you to write workers just like your typical web
worker code with none of the boilerplate and all of the type-safety. Let's look
at a simple example:

```ts filename="myThread.ts"
'use thread';

export function adder(a: number, b: number) {
	return a + b;
}
```

Here we've specified the module is a thread with `'use thread';`. This sort of
statement is likely familiar to those who work in the broader Javascript
ecosystem, with `'use strict'` and NextJS's `'use client'` and `'use server'`.
This statement is expanded by the transformer into an event handler that allows
the module to receive events posted from the main thread. We also `export` the
function we want exposed to the main thread - only exported fields are public!

How does one access threads? Just like any other data or functionality - a
system parameter!

```ts filename="myMainThreadFile.ts"
async function systemThatUsesThreads(
	thread: Thread<typeof import('./myThread'))>
) {
	const result = await thread.run('adder', 1, 1);
	console.log(result); // -> 2!
}
```

In our system, we declare that we'd like to access the provided module as a
thread. We're given a wrapper (`Thread`) over the worker which provides us with
strong typesafety guarantees. We only exposed `adder`, so that's the only string
`Thread` will recognize here, and it knows the number and types of arguments as
well as the return! As worker code is inherently async, `thread.run()` returns a
promise that resolves to whatever value was returned by the function called in
the other thread.

Of course, you aren't required to immediately await this promise in the system -
you can choose to handle it however you like. There's also no problem with
calling `thread.run()` again before the Promise has resolved - queue up as many
tasks as you need run! Arguments and return values are structured-cloned when
sent between threads, so be aware that only structured-cloneable values can be
sent across threads.

There may be cases where you may want to set a value in a worker from the main
thread - or maybe you'd like to actually [transfer]() an object. We provide two
primitives for this as well. Simply export mutable bindings from the worker...

```ts
'use thread';

export let canvas: OffscreenCanvas;
export let width: number;
export let height: number;
```

...and `send()` or `transfer()` their new values from the main thread!

```ts filename="myMainThreadFile.ts"
async function someSystem(
	thread: Thread<typeof import('./myThread'))>
) {
	const width = window.innerWidth;
	const height = window.innerHeight;
	await thread.transfer('canvas', new OffscreenCanvas(width, height));
	await thread.send('width', width);
	await thread.send('height', height);
}
```

Here we've transferred an OffscreenCanvas object to the thread and set the
`canvas` variable to it, as well as setting the `width` and `height`. Remember
that these must be `let` statements to be reassigned.

`'use thread'` does _not_ have to appear at the top of a module - for example,
you could wrap it in `if (typeof document !== undefined)` if you also import the
thread module on the main thread and want to avoid setting up event listeners
that won't be used.

Lastly, we've added a new piece of config - `createWorker(url: string): Worker`.
This config accepts a url for the worker and should return a new worker-like
object. This does _not_ have to be identical to `Worker` as seen in browsers -
it only needs to have methods for `addEventListener()`, `postMessage()`, and
`terminate()`.

### The Future

This is very much a first iteration of threads. While these primitives are in
solid shape, there's a lot of room to grow from this foundation, including task
pools, allowing systems to be called in threads, and finding ways to gracefully
prevent the total thread count exceeding `navigator.hardwareConcurrency`.

## Removal of `run()`

`run()` was only necessary for smart scheduling, allowing us to eek out as much
parallelism as possible while enabling consumers to enforce ordering of systems.
However, most consumers likely want a strict, consistent ordering of systems
(which `run()` did _not_ guarantee), and the new concurrency model requires
thread usage to be explicit anyway. As a result, **`run()` has been removed and
systems will execute in the order they are added**. This is essentially already
the previous behavior if you were only using single-threaded execution!

## Mutable Default

With the changes to the threading model, it was also time to reconsider
mutability as well. If you only ever run code on one thread, the benefits of
readonly default are more organizational than performance oriented. Wrapping
types in `Mut` is also somewhat counterintuitive as typically mutability is the
language default and you must specify `Readonly`. This is especially noticeable
with queries, where the accessors you specify in `Query<A>` aren't exactly what
you get in iterations.

For 0.16, **`Mut` has been removed**. You may wrap your types in `Readonly` if/
when you'd like - it's usually a good idea, but not mandatory. We also provide a
stricter `Read<T>` type; Typescript's provided `Readonly` does not enforce
nested objects to be readonly and allows methods that self-modify - `Read<T>`
guarantees this strictness. `Read` and `Readonly` are treated identically in
terms of transformation. Altogether, these changes should allow your apps to be
safer than before!

## Other Changes

### Entity Liveliness

As components are no longer pooled, it's safe to hold on to references of
`Entity` components. To make working with entities easier, an `isAlive` property
has been added to `Entity`; once an entity has been despawned (_after_
`applyCommands` runs), it will be `false`. `Entity` components are never reused
so once `isAlive` is false you should drop references to the object.

### Removal of Registration

The need for registering types before building a world has been lifted -
resources and components can be added at runtime. In the future, we'll add new
APIs to make it easier to take advantage of runtime components and dynamically
adding systems.

### `Memory` Removed

When custom memory allocation was first added, it provided significant
flexibility in what could be achieved with threads, only requiring most data to
be sent across threads once. This design was incredibly powerful, but it also
adds a _significant_ amount of code that must ship with all Thyseus consumers,
while only benefiting those using concurrency. It was also the source of most of
our complexity - most bugs that have been reported in Thyseus since the
introduction of `Memory` were caused by it. Worse, it also put us on the hook
for allocation-related performance. With many of the assumptions about the needs
of threads challenged, we were able to fully remove the `Memory` API.

### Simplified System Parameters

The changes to threads mean that system parameters can be much simpler - in
fact, you only need to provide `intoArgument` for your own system parameters
now. These will likely be expanded once again in the future as the threading API
matures, but for now we wanted to remove the dead weight.

### World Config Changes

With the changes to threads and the removal of `Memory`, most of the options
available in `config` have been made obsolete. The aforementioned
`createWorker()` config is the only remaining config at the moment!

### Better Inline Documentation

Quite a bit of documentation has been added to different classes and their
methods - it should be easier than ever to understand what Thyseus can do from
the comfort of your editor! As always, we're continuing to update and improve
the docs on the site as well.
