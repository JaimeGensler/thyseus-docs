{
	"/docs/advanced_patterns/custom_executors": {
		"title": "Custom Executors",
		"data": {
			"": "An Executor is responsible for determining how to execute the systems in a\nworld. This includes respecting dependencies, protecting against intersections,\ndetermining resource locality, and actually calling system functions.There are a few reasons you may want to use a different executor. Thyseus\nactually provides two executors out of the box - SimpleExecutor for single\nthreaded worlds, and ParallelExecutor for multithreaded worlds. Single\nthreaded worlds don't have to worry about concepts such as resource locality or\nproblems that can arise from running intersecting systems in parallel. As a\nresult, they can have significantly simpler execution logic. When a world is\nbuilt, Thyseus checks if you're using multiple threads or not and picks the\nexecutor to use.Another reason to use a different executor is if you want to take advantage of a\ntechnology that you know will be available in your environment that the default\nexecutor doesn't use (like Atomics.waitAsync). Or, perhaps you want additional\nguarantees that the defaults don't provide, like stable execution order. These\nbecome possible by providing a custom executor implementation.There are many ways to implement a working executor, each with different\ndifficulties - this page will only cover API requirements and mandatory\nfunctionality.",
			"using-a-custom-executor#Using a Custom Executor": "You can specify a world's executor by using the world builder's setExecutor\nmethod. This method accepts one argument - an ExecutorType, shown below:\nAs with most internal APIs, Thyseus implements this as a class:\nAnd as with most APIs, you may choose to implement this however you wish!\nThe world is still being constructed when fromWorld() is called. All\nproperties (except executor) have been set, but not all properties have\nbeen populated (e.g., world.resources is accessible but will have no\ncontents).",
			"threadgroup-queues#ThreadGroup Queues": "Because executors are created while the world is being constructed, they are\nable to use special ThreadGroup functionality that is not normally available.The ThreadGroup.prototype.queue() method accepts a \"creator\" function that, on\nthe main thread, calls that function to create a value, adds the value to a\nqueue, and returns the value. This contents of this queue can then be sent to\nworker threads. When this method is called in a worker context, it merely\nremoves and returns the next value from the queue. This provides a simple way of\npropogating values across threads as long as threads are executing the same\ncode! Because this method requires that threads are executing the same code in\nthe same order, this method only works during world construction. This is\nparticularly useful for data structures backed by SharedArrayBuffer.This method depends entirely on the order in which values are created - it is\nimperative that you do not wrap queue in a context-specific conditional!",
			"executor-requirements--guidelines#Executor Requirements & Guidelines": "For an executor to work, it must:\nFollow the above API requirements.\nstart() must return a promise that only resolves when all systems finish\nrunning.\nstart() must call system functions with their arguments.\nBuilt systems are available as world.systems. Their arguments are\navailable as world.arguments.\nOnly run each system once.\nFor an executor to meet Thyseus' executor guarantees, it must:\nOnly run systems on the main thread if it uses thread-bound arguments.\nEnsure that intersecting systems do not run in parallel.\nRespect system dependencies.\nIf you are creating a third-party library that includes a custom executor, your\nexecutors could provide additional guarantees. For example, the default executor\ndoes not guarantee a stable execution order, so systems may be called in\ndifferent orders frame to frame (assuming no dependencies). Your executor could\nchoose to construct a single execution order, and guarantee that your systems\nare always called in order.Technically, you also have the option to break Thyseus' execution guarantees,\nsuch as ignoring dependencies or intersections. If you do so, you should denote\nexactly how you break these guarantees for consumers!"
		}
	},
	"/docs/advanced_patterns/memory": {
		"title": "Memory API",
		"data": {
			"": "Working directly with the Memory API comes with significant risks.\nIncorrect usage of the API can lead to corruption of any or all\nThyseus-specific data in an application. Proceed with extreme caution.\nThyseus uses a custom memory allocator to have fine-grain control over memory\nlayout in applications. It allocates an ArrayBuffer when a world is built and\npartitions it as needed with functions like Memory.alloc(), Memory.free(),\nand more. Reading and writing data in this memory is handled with pointers -\nunsigned integer offsets, which can be used to index into views over the buffer.This page will give you an overview on how to use the allocator, but will not\ncover detailed usage such as thread safety. Note that any behavior you observe\nwith the allocator that is not documented here (e.g., a minimum pointer value) -\nno matter how consistent it appears to be - is not guaranteed behavior and\ncould change in a patch or minor release, without documentation.\nIt is very easy to write broken code with this API, and there are very few\nbuilt-in guardrails against incorrect use - write tests!",
			"allocating#Allocating": "After memory has been initialized, memory can be allocated with\nMemory.alloc(size: number): Pointer.\nNote that pointers are always 8-byte aligned, and so can be used to index\ninto any memory view. Also note that the allocator is thread-safe, so you need\nnot worry about calling alloc() (or realloc(), or free()) at the same time\non different threads.The allocator may choose to reserve more space than requested, but will never\nreserve less. If there is not enough space for it to complete an allocation, an\nerror will be thrown.",
			"reallocating#Reallocating": "For dynamically sized types, you may need to reallocate a previously\nallocation with a new size. This can be done with the provided realloc() and\nreallocAt() functions.\nAs an optimization, realloc() will perform a zero-copy in-place grow if\npossible. If it cannot, it will allocate, copy, and free.\nAfter a pointer has been reallocated, its previous value is invalid and must not\nbe used. Bear in mind that realloc() cannot update pointers held locally in\nother threads. For example:\nThis appears okay - but imagine that MyDataStructure is constructed in\nanother thread, sharing the same pointer in that thread:\nIn the above case, the pointer on the class will be updated on the main\nthread, but not in the worker thread. When we try to access the pointer in a\nworker thread, we will be using a pointer that has been freed!To resolve this, the primary pointer that is shared between both threads\ncannot change. That pointer must point to another pointer, which can be\nresized.\nIn the vast majority of cases, realloc() will be used on pointers held in the\nbuffer itself like the above example. For this reason, a reallocAt() function\nis provided. reallocAt() accepts a pointer and a new size, and treats the u32\nvalue at that pointer as a pointer itself.\nNow we're safely reallocating!",
			"using-pointers#Using Pointers": "Memory that you have not claimed for yourself belongs to the allocator. The\nallocator may use memory it owns for internal purposes; writing to values\nthe allocator owns will likely result in infinite loops and complete\ncorruption of data in the buffer.\nNow that you own a section of memory, you may read and write values from it. The\nMemory object exposes a view of every type over the entire buffer:\nMemory fields will be null until the memory has been initialized.\nBecause a pointer is a byte offset in memory and typed array access uses\nindexes, you'll need to do a little pointer manipulation when accessing typed\narrays with value sizes larger than a single byte. Fortunately, this is as\nsimple as shifting bits:\nTo access an offset of your pointer that you own, you can do pointer arithmetic.\nIt is your responsibility to ensure that you are using pointers correctly\nand only accessing data you own. The allocator does not and cannot do bounds\nchecks on your memory access, so you will not be stopped from writing to memory\nregions outside of your allocated range.",
			"freeing#Freeing": "When you are done with your allocated section of memory, you must call free().\nThe allocator does not automatically garbage collect - you are responsible for\nfreeing memory you no longer need. free() accepts a pointer, and allows that\nsection of memory to be allocated again.",
			"utilities#Utilities": "The Memory object also exposes a few additional functions for convenience.\ncopy(from: Pointer, length: number, to: Pointer): void, which accepts a\npointer to start from, a length (in bytes) to copy, and the destination to\ncopy data to.\ncopyPointer(pointer: Pointer): Pointer, which allocates a new pointer of\nthe same size as pointer, copies data from pointer, and returns the\nnewly allocated pointer.\nset(from: Pointer, length: number, value: number): void, which sets a\nspecified range to the specified value, starting at the provided pointer\nfor the specified length (in bytes).",
			"special-semantics#Special Semantics": "For ease of use, some memory functions have special semantics when called with\nparticular values.\nCalling free() with 0 or the null pointer results in a no-op.\nCalling realloc() with 0 or the null pointer is equivalent to calling\nalloc() with the specified number of bytes.\nCalling copyPointer() with 0 or the null pointer simply returns the null\npointer.\nIn dev only, calling free() or realloc() with a pointer that is\nnot 8-byte aligned (i.e., an invalid pointer) results in an error being\nthrown.\nIn dev only, calling reallocAt() with a pointer that is not\n4-byte aligned results in an error being thrown.\nIn these cases, the \"null pointer\" refers to the allocator's internally held\nnull pointer, not the Javascript null value."
		}
	},
	"/docs/core_concepts/components": {
		"title": "Components",
		"data": {
			"": "A component is a self-contained unit of data that belongs to an entity. An\nentity can have 0 or more components and can add or remove components throughout\nthe course of its life. Components can describe any data belonging to an entity,\nsuch as Transform, Health, Inventory, IsPlayer, and anything else you\nneed.",
			"writing-components#Writing Components": "Components are classes decorated with the @struct decorator. They can describe\nproperties and must give each property an explicit type:\nThe above defines a Health component with two properties - the max and\ncurrent health of the entity it belongs to. We've also added initializers and\ngiven each property an explicit type.",
			"types#Types": "Component fields may be a subset of types. The primitives permitted are:\nName\tDescription\tSize (bytes)\tAlias for\tboolean\ttrue or false\t1\t-\tnumber\tIdentical to f64\t8\t-\tu8\tUnsigned 8-bit integer\t1\tnumber\tu16\tUnsigned 16-bit integer\t2\tnumber\tu32\tUnsigned 32-bit integer\t4\tnumber\tu64\tUnsigned 64-bit integer\t8\tbigint\ti8\tSigned 8-bit integer\t1\tnumber\ti16\tSigned 16-bit integer\t2\tnumber\ti32\tSigned 32-bit integer\t4\tnumber\ti64\tSigned 64-bit integer\t8\tbigint\tf32\t32-bit Floating Point number\t4\tnumber\tf64\t64-bit Floating Point number\t8\tnumber\t\nnumber and boolean work as expected, but components also allow other numeric\ntypes. If you're not used to working with multiple numeric types, don't worry;\nnumber is a fine choice getting started, it just may not always be the best\nfit!\nWhen handling instances, all numbers behave as typical Javascript numbers\n(double-precision floating point numbers). They are casted into the narrower\ntype you specify when serialized, which is observable once the instance is\ndeserialized again.\nA more appropriate choice for our Health component might be u32:\nSome complex types are also permitted in structs, including strings, numeric\ntuples (fixed-size same-type arrays) and other structs.\nNumeric enums may also be used as struct types, and will be serialized as the\nsmallest matching numeric:\nStructs also allow variable-sized same-type arrays - these arrays may contain\nany of the numeric primitives seen above.",
			"methods#Methods": "Directly mutating the values of instances is often good design, but in some\ncases it may lead to issues. Consider our Health component: there's nothing\nfrom stopping current from exceeding max, which we likely do not want. This\nis a great case for methods:\nWe've converted the max and current properties to be # private, requiring\nconsumers to use the heal() and takeDamage() methods. This protects us from\ninteger underflow and current exceeding max, while keeping our code dry,\nlocalized, and easily testable.",
			"constructors#Constructors": "Structs may define constructors if needed. The only requirement is that if a\nstruct is being used as a component, the constructor must not have any\nrequired arguments. If you're simply using it as a type for another struct,\nrequired arguments are permitted.\nLike initializers, constructors can also define default values; in the above,\nadding the Health component by type will result in both current and max\nbeing 100.",
			"inheritance#Inheritance": "Structs may be extended:\nIf you'd like to add additional properties to the extended class, make sure to\ndecorate the class again.",
			"zero-sized-types-zsts#Zero-Sized Types (ZSTs)": "In some cases, you may want to add a \"tag\" to entities (e.g., IsPlayer) but\nhave no additional data associated with that component. In these cases, you can\nuse a zero-sized type. As the name implies, these are structs that require\nno space when stored.",
			"disallowed-property-names#Disallowed Property Names": "The compiler adds additional properties to struct, which means that structs must\nnot define these properties. In particular, structs may not have the following\nproperties/methods:\nstatic size\nstatic alignment\nstatic drop() {}\n__$$b\nserialize() {}\ndeserialize() {}\nIt is permitted to define these properties in your structs and access them so\nlong as you know they'll be overwritten!"
		}
	},
	"/docs/core_concepts/entities": {
		"title": "Entities",
		"data": {
			"": "Entities are the building blocks of an ECS. Any concrete \"thing\" in your game\nworld can be represented as an entity; players, enemies, items, the game level\nitself, even parts of the UI - all entities! Conceptually, an entity is simply\nan empty container for any number of components, and contains no special\nproperties, data, or meaning on its own. In practice, an entity is nothing more\nthan an integer id.Because entities contain no inherent data or meaning, it's not particularly\ncommon to deal with them directly; instead, you'll usually interact with\ncomponents, the data that belongs to an entity.",
			"creating-entities#Creating Entities": "New entities can be created using Commands. We'll cover systems and the\nCommands API more in the future - for now, we'll write some very simple\nsystems to show you how to work with entities!\nThis is a basic system that accepts the Commands object. commands.spawn()\nqueues an entity to be spawned and returns an EntityCommands object. This\nobject can be used to queue additional commands to insert (or remove) components\nfor that entity. It also provides a getter to see the id of the newly spawned\nentity.Entities are not created immediately. Instead, Commands reserves an id and\nadds the entity creation request to a queue. Entities are created later when the\napplyCommands system runs, which drains the queue of all commands. Created\nentities are not observable until after commands have been applied!",
			"accessing-entity-ids#Accessing Entity IDs": "Every entity possesses a special Entity component. This component allows you\nto access the entity's id, and can be queried for in systems (queries will be\ncovered more later, too!).",
			"destroying-entities#Destroying Entities": "Of course, not all entities will live forever. You can use Commands or\nEntityCommands to queue an entity for destruction; just like creation,\nentities are not destroyed until the applyCommands() system runs!"
		}
	},
	"/docs/core_concepts/systems": {
		"title": "Systems",
		"data": {
			"": "Systems are where the functionality of an ECS application lives and are the\nfundamental way you read and write data. Most often, systems are used to query\nfor entities with particular components, but they can also be used to spawn\nentities, handle events, draw to canvases, serialize data & write it to the file\nsystem, or anything else you might need them to do.",
			"defining-systems#Defining Systems": "Systems being functionality, it's only natural for them to be functions! A\nfunction is a system if it accepts only \"system parameters\". They may accept\nzero, one, or many parameters - even multiple of the same type of parameter! So\nlong as every parameter is a system parameter, it's a system.We've already seen a couple simple systems - let's start by revisiting those.",
			"basic-commands-system#Basic Commands System": "In the entities section, we saw a system that used the Commands object.\nCommands is one of the built-in system parameters, and is responsible for\nspawning entities. Now that we know about components, let's try spawning an\nentity and adding a component to it:\nWhen this system runs, it will be called with a Commands object, which we can\ndo whatever we need with - check out the\nCommands page to see what else you can do\nwith commands!",
			"basic-queries-system#Basic Queries System": "Next, let's look into queries more - they're probably the most used parameter!\nThere's a lot more going on here, so let's work through it piece by piece.\nFirst, we're defining a system that accepts one argument - a Query. This query\nwill look for entities that have both a Position and a Velocity component -\nevery entity that has at least both of these components will match this query.\nIn the function body, we're iterating over the query - this means we're getting\nthe Position and Velocity components for every entity the query matches. For\neach entity, we're simply logging the position and velocity. In future examples,\nwe'll do a lot more!",
			"other-system-parameters#Other System Parameters": "Queries and Commands are just two of the system parameters Thyseus provides out\nof the box; your systems can get much more complex, using multiple queries,\naccessing resources, reading & writing events, or accessing the world itself.\nLater sections will cover all of the system parameters in depth - and if you\nneed system parameters not provided by Thyseus, you can even\ncreate your own.",
			"system-transformation#System Transformation": "The transformer takes care of making sure that systems receive the arguments\nthey need. It comes with a couple usage caveats.\nOnly function declarations and functions in variable initialization are\ntransformed. Function expressions passed inline to other functions won't\nbe transformed, but you can always provide parameters manually.\nType aliases (including import aliases) are not permitted; simple\naliases (type MyQuery = Query<...>), or \"namespaced\" types\n(Thyseus.Commands) will not be transformed. Support for this is planned\nfor a future update.\nFunctions with rest parameters will not be transformed, even if the\nparameters are typed as a tuple containing only valid system parameters.\nImport classes, not just types. When using class types, the transformer\nassumes the actual class is in scope; if you get a reference error, it's\nprobably this.\nSystems can't be generic. Of course, you can still create generic \"base\"\nfunctions and call them in systems with your non-generic data.\nFunctions that accept only system parameters will have a parameters\nproperty added, even if they aren't used as systems. This is more-or-less\nharmless; you can ignore or //thyseus-ignore it - up to you!",
			"systems-without-transformation#Systems Without Transformation": "If you're using plain Javascript, are building third-party libraries, or simply\ndo not wish to use the transformer plugin, then you will need to provide system\nparameter information yourself. Thyseus uses this information to determine what\ndata your systems want from a world, as well as how it's accessed.Fortunately, writing systems without the transformer only involves one\nadditional step - adding a parameters property to the function. Here's what\nthe above examples would look like without the transformer:"
		}
	},
	"/docs/core_concepts/worlds": {
		"title": "Worlds",
		"data": {
			"": "Worlds contain your entities and components, and are responsible for executing\nsystems. Every world is independent and self-contained; systems and types can be\nused by multiple worlds, but data belongs to a single world. Many applications\nonly need a single world - particularly starting out - but sometimes multiple\nmay be the right choice.",
			"adding-systems#Adding Systems": "Worlds start with a WorldBuilder and the World.new() method. The\nWorldBuilder is responsible for registering all systems and types that will be\nused in a particular World; all systems and types a world will use must be\nregistered. Let's create one now:\nFortunately, you typically only need to worry about adding systems to your\nworld; when you add a system, it can (usually) handle registering the types it\nneeds! Let's add a system now:\nBy adding this system, we've also registered the Inventory & IsPlayer\ncomponents.Most methods on WorldBuilders return the WorldBuilder itself, so they can be\nchained. Let's add a few more systems!\nOf course, it's called addSystems for a reason:",
			"building-a-world#Building A World": "When you've added all the systems you'd like, you can build your world and start\nexecuting systems. We can use the build() method for this, which returns a\npromise that resolves with your completed world. Let's try it now with a system\nthat just calls console.log:\nTop-level await is a convenient way to handle the promise returned by\nbuild() - especially when starting out - but is not required.\nCool, but just building a world doesn't start your systems. Let's set up a loop\nto call our system!\nHere, we're using the runSchedule method - we'll cover schedules next, but for\nnow all you need to know is systems are added to the DefaultSchedule when you\nuse addSystems, and calling runSchedule runs all systems in a schedule.If you look in your browser's log, you should see a whole lot of\n\"Hello, world!\"s!",
			"schedules#Schedules": "Worlds can contain multiple groups of systems called schedules. Schedules\nrun all the systems they contain together before execution of other schedules\nmay occur. However, schedules may contain systems that execute other\nschedules.Schedules have a number of different uses - they can be used to create a group\nof systems that only runs when your app starts, or when tearing down, or systems\nthat need to run at a fixed rate!By default, Thyseus provides two schedules - the DefaultSchedule, which\nsystems are added to when calling addSystems, and the StartSchedule.",
			"startschedule#StartSchedule": "The StartSchedule is intended to control the execution of all other schedules.\nIt is run when world.start() is called. Let's rewrite the above example using\nthis:\nThis is essentially the same as the previous example, but now we've localized\nall our startup logic to our startSystem. Using world.start() comes with the\nadded bonus that it can safely be called from any thread (unlike\nworld.runSchedule, which must only be called from the main thread).",
			"dependencies#Dependencies": "By default, Thyseus makes no guarantees about the order in which systems will be\nexecuted - it may be completely stable, or it could change every execution. If\none of your system needs to run before or after another system, you can\nspecify system dependencies using the run function.\nContradictory dependencies like run(A).after(A) or\nrun(A).after(B), run(B).after(A) will cause an error to be thrown when the\nworld is built.",
			"plugins#Plugins": "Plugins are simply functions that accept a WorldBuilder instance and register\nsystems and types on that WorldBuilder. Plugins give you the flexibility to\nchange the implementation details of a piece of functionality without changing\nthe external API."
		}
	},
	"/docs/getting_started/installation_and_setup": {
		"title": "Installation & Setup",
		"data": {
			"": "This guide assumes that you are using a\nRollup-based bundler. The official Thyseus\ntransformer is available as a (Vite-compatible) Rollup plugin. If you'd like\nsupport to be added for your bundler of choice, please file a\nticket!",
			"package-installation#Package Installation": "To get started with Thyseus, install the core library:",
			"transformer-setup#Transformer Setup": "Thyseus makes use of a code transformer to make your code more performant and to\nprovide better DX. All docs will assume you're using the transformer - if you're\nnot, you'll need to\nreview the systems docs.The transformer also requires the use of Typescript; if you don't have\nexperience with Typescript, it's recommended that you\nget familiar with the basics\nbefore starting with Thyseus.Currently, the transformer is available for Rollup.\nThe Thyseus transformer for Rollup is a plugin. Install:\nAnd configure:\nNote that thyseusPlugin() must appear before typescript() in order to work, as the plugin transpiles Typescript to Typescript.\nThe Thyseus transformer for Vite is a compatible Rollup plugin. Install:\nAnd configure:",
			"typescript-setup#Typescript Setup": "Thyseus currently uses legacy decorators; your tsconfig.json must include\n\"experimentalDecorators\": true.",
			"global-type-setup-optional#Global Type Setup (optional)": "ECS is a data-oriented paradigm and makes heavy use of types. Thyseus provides\ntwo way of accessing its types - direct imports from 'thyseus', or a global\ntype injection. The choice of which to use is entirely up to you!If you'd like to use global type injection, you can add the following to your\nTypescript config:\nIf you'd rather not, types can simply be imported:\nFor the sake of brevity, code snippets in the docs will assume you are using the\nglobal type injection.",
			"development-vs-production-builds#Development vs. production builds": "Thyseus uses esm-env to determine\nwhether you're building your app for development or production. Dev builds have\na number of additional correctness checks and validations that help you make\nsure your app works correctly and that thrown errors are easily debuggable.\nThese checks come at the cost of speed, so for production builds these checks\nare stripped out. As long as you're using a modern bundler, this should happen\nautomatically."
		}
	},
	"/docs": {
		"title": "Introduction",
		"data": {
			"": "Thyseus is an Entity Component System (ECS) framework written in Typescript.\nTaking much inspiration from Bevy, it aims to provide\na best-in-class developer experience without sacrificing performance.ECS is a data-oriented design approach to development - typically used for game\ndev - that promotes modularity and reusability by separating data and behavior.\nIt consists of entities, which are unique identifiers; components which\nare plain data without behavior; and systems, which operate on data. For a\ngood introduction to the paradigm, read the\nECS FAQ by Sander Mertens.Thyseus is a powerful foundation for you to build your own complex applications\non that remains deeply configureable and composeable. It supports a number of\nfeatures out of the box, including:\nA safety-first approach (no eval or eval-like constructs)\nHassle-free multithreading\nArchetypal storage\nComplex queries\nDeeply customizable execution logic\nDynamically-sized types\nWorld-unique data\nEvent handling\nFine-grain memory management\nIntegration with third-party libraries\nLet's dive into it!"
		}
	},
	"/docs/multithreading": {
		"title": "Multithreading",
		"data": {
			"": "As with any other Javascript, your code runs on a single thread by default.\nHowever, Thyseus empowers you to take advantage of parallelism with a simple\nchange of configuration. You don't need to worry about scheduling, locks,\ncreating and communicating between workers, or how to share/propogate data - all\nof this is handled internally!It also provides a number of safety guarantees. Parallelism is enabled by taking\nadvantage of technologies offered by modern browsers; there is not and will\nnever be unsafe code, such as using eval or eval-like constructs, creating\nworkers from blobs, or any other type of run-time code generation. Your Thyseus\nprojects are exactly as safe as the code you write, and changing between\nsingle/multithreading does not change this.Parallelism won't necessarily automatically improve the performance of your\napplications - in fact, in simpler projects it will likely harm performance.\nIf and by how much parallelism can help your performance depends on a number of\nfactors including the number of systems you have & how parallelizable they are,\nthe number of threads, the parallel executor implementation, the target\nenvironment, and more. Benchmark to see if it helps in your case!",
			"compatability-with-other-multithreading-solutions#Compatability with other multithreading solutions": "Thyseus's parallelism is not designed to be easily compatible with other\nmultithreading solutions. While this is an area for future exploration, for now\nthere are a couple workarounds.If you would like to use a different multithreading model altogether, you can\nstill specify that you want Thyseus to use a SharedArrayBuffer for your data\nin your world configuration:\nAlternatively, if the functionality of other libraries can be expressed as\nThyseus systems, they should be able to reap the benefits of multithreading as\nwell.Finally, custom executors can also be\nused to change the way systems are executed in parallel according to your own\nneeds."
		}
	},
	"/docs/multithreading/usage": {
		"title": "Using Multiple Threads",
		"data": {
			"": "Now that you know all the rules of multithreading, let's get going with parallel\nexecution!",
			"world-config#World Config": "Provided all the rules are followed, running your systems on multiple threads\nwith thyseus is as simple as changing configuration.\nthreads must be at least one - { threads: 1 } indicates that the world will be singlethreaded.\nThe above configuration will run your systems on two threads - the main thread\nand one worker. In general, if you want to maximize performance, you'll want to\nuse navigator.hardwareConcurrency:\nExceeding hardwareConcurrency (assuming it is available) will not result\nin better performance, and in fact will usually result in worse performance.\nIf you'd prefer to target a specific number of threads without exceeding\nnavigator.hardwareConcurrency, you should clamp the value (e.g.,\nMath.min(navigator.hardwareConcurrency ?? 1, yourTargetThreadCount)).\nIf you're targeting newer versions of Safari and would like to enable\nmultithreading, you will need to use some form of user agent\nsniffing\nor a polyfill for\nnavigator.hardwareConcurrency.",
			"wait-thats-it#Wait... that's it?": "Pretty much! Because systems must specify the data they use and how they use it,\nThyseus is able to determine what systems can run in workers (as opposed to the\nmain thread only) as well as what systems can run in parallel, and can\nparallelize your systems for maximum performance without you needing to do\nanything more.However, that doesn't mean there's nothing you can do to improve multithreaded\nperformance. There are a few general guidelines that can help you write more\nperformant systems:",
			"1-only-request-mutable-access-if-you-really-need-it#1. Only request mutable access if you really need it.": "Writing data, whether that's queries or resources, forces a lock on that data\nand prevents any other systems from reading or writing it until that system is\nfinished executing.",
			"2-use-query-filters-if-you-dont-need-access-to-component-data#2. Use Query Filters if you don't need access to component data.": "As mentioned in the queries section, query filters do not impact whether systems\ncan run in parallel as they do not actually access any data. If you want to\nguarantee the presence of a component, but do not need to read or write data,\nyou should always use a query filter.",
			"3-keep-your-systems-small-and-focused#3. Keep your systems small and focused.": "In general, the more data a system needs access to - even readonly access - the\nmore likely it is that that system will not be able to run in parallel with\nother systems. If there are more systems that can run in parallel (even if there\nare more systems overall), threads will spend less time waiting for data to\nbecome free and more time running your code!In general, the more granular your data and data access, the better!",
			"how-do-i-know-which-thread-a-system-will-run-on#How do I know which thread a system will run on?": "The default executor does not generate a single schedule to follow - this is to\nprevent systems with longer execution times from preventing overall progress.\nInstead, it tries to see if any of the remaining systems are able to run. It\nexecutes the first system it finds if one is available. If there aren't any that\ncan be run, it waits until another thread has finished executing a system and\ntries again. This means that, except for mainthread-only systems, any system can\nrun on any thread, and can change which thread it executes from frame to frame.Thyseus also does not have a robust notion of thread identity. That is, a thread\nis either the main thread (which has some additional\ncapabilities/responsibilities), or it's one of the worker threads. There is at\npresent no way of dedicating one particular thread for one particular type of\ntask or set of systems."
		}
	},
	"/docs/reference/glossary": {
		"title": "Glossary",
		"data": {
			"struct#Struct": "In languages like C and Rust, structs are similar to Javascript objects, but\ntheir keys and the types of their values are known at compile-time and can be\noptimized as a result. Structs in Thyseus are intended to emulate these structs,\nand so their size must be constant.",
			"resources#Resources": "World-unique data. Some ECS libraries use singletons to model world-unique data\n(components that only exist on one entity). Because this pattern of needing\nworld-unique data is so common, Thyseus treats it as a first-class concept.\nResources are just classes - if they correctly implement the requirements of\nStructs, they can be shared across threads.",
			"system-relationships#System Relationships": "In a multithreaded environment, systems can have one of two relationships to one\nanother - Disjoint or Intersecting. When two systems are Disjoint, it\nmeans that neither system will write data that the other is trying to read or\nwrite. Systems that read (and only read) the same data remain disjoint. Disjoint\nsystems may execute in parallel. Intersecting systems are the opposite of\nDisjoint systems - one (or both) of the systems writes to data that the other\nsystem must also read or write. Intersecting systems cannot execute in parallel.In general, you don’t have to think about whether systems are disjoint or\nintersecting - Thyseus can automatically determine the relationship between\nevery system in your world. However, it is important to make sure you’re only\nrequesting write access when your system needs it, or in certain cases to break\na system into multiple smaller systems if it requires mutable access to a lot of\ndifferent data. The page on\nusing multiple threads goes into\ndetail about getting better multithreaded performance, and the guide to\ncustom system parameters explains\nmore how intersection is determined.",
			"dependencies#Dependencies": "Dependencies are requirements that must be met before a system can run. A system\ncan specify that certain systems must before it may run as well.",
			"zero-sized-type-zst#Zero-Sized Type (ZST)": "Zero-sized type. This refers to structs that are used as markers (or tags, or\nflags) for entities, and whose storage does not take up any space.",
			"archetype--table#Archetype / Table": "There are numerous approaches to writing an ECS - Thyseus uses an\narchetypal\ndesign.An entity's archetype refers to the collection of components (including\nZSTs) that entity possesses. In Thyseus, this is represented as a bigint.Component data is stored in tables, where each column is the data for a\nspecific component type, and each row represents an entity and its unique data.\nTables do not include columns for ZSTs because ZSTs contain no data. Entities\nwith the same archetype are (usually) stored in the same table, but in some ECS\nimplementations entities in the same table can have different archetypes.This strategy generally makes iterating over entities extremely cache-friendly\nat the cost of making changes to an entity's archetype - a table move - a bit\nmore expensive."
		}
	},
	"/docs/system_parameters/commands": {
		"title": "Commands",
		"data": {
			"": "The Commands object can be used to spawn & despawn entities, add components to\n& remove components from entities, and clear event queues. Individual commands\naren't processed immediately - instead, each command is added to a queue. The\nentire queue of commands is later processed in a system called applyCommands -\nthe effects of commands are not observeable until after this system runs.Let's look at how to use Commands!",
			"setup#Setup": "Thyseus is built for a wide variety of use cases - this makes it versatile, but\nit also means it doesn't make assumptions about how your app will or should\nwork. As a result, you must add the applyCommands system yourself. You can\nimport applyCommands and add it to whatever schedule you need (and as many\ntimes as you need with cloneSystem).Starting out, it's usually a good idea to add it to the end of the\nDefaultSchedule.",
			"spawning-entities#Spawning Entities": "The most common use of commands is spawning entities.\nThe spawn() method returns an EntityCommands object that can be used to\ninsert additional commands for that entity - like adding or removing components.If you need to \"reobtain\" the EntityCommands for an entity, you can use\nget():",
			"addingremoving-components#Adding/Removing Components": "Commands are also how we add & remove components on entities.To add components, we can use the addType() method. addType() allows you to\nadd components by type - when commands are applied, that component will\nreceive the default values for the component. Adding by type is especially\nuseful for ZSTs!\nSometimes you'll want to have some initial data for components. To do this, we\ncan use add().\nadd() copies the data for the passed component.When an entity should no longer possess a component, you can use remove():",
			"despawning-entities#Despawning Entities": "When you're done with an entity, you can use the despawn() method:",
			"parallelism#Parallelism": "Commands is designed to be safely accessible in parallel - systems on any\nthread can safely push commands to the queue at the same time as other systems.\nThe applyCommands system requires access to the World, and as such creates a\nhard sync point."
		}
	},
	"/docs/system_parameters/events": {
		"title": "Events",
		"data": {
			"": "Events allow you to run logic in response to something that happened in your\ngame, and can be used as a means of cross-system communication. Events are\ninstances of Structs, and live in a queue of other events of the same type.\nNew events can be pushed to the queue with EventWriter<T>, and events in the\nqueue can be read with EventReader<T>.Events have no set lifetime - they will persist until the queue is manually\ncleared. Both readers and writers can call the clear() method to queue a\ncommand that will empty the event queue the next time commands are processed.\nThis only clears events of the queue's event type, and not queues for other\nevent types.",
			"eventreader#EventReader": "EventReaders are responsible for reading data from the event queue.They can be iterated over in a for...of loop, and will yield instances of the\nevent type (Readonly<T>). You can also check their length to determine the\nnumber of elements in the queue.\nLike queries, Thyseus reuses the same object with different backing data\nwhen iterating events.",
			"eventwriter#EventWriter": "EventWriter inherits all functionality of EventReader, and is also\nresponsible for adding events to the queue. There are two provided methods of\ndoing so:\ncreateDefault(): void adds an element to the queue with the default data\nfor that struct.\ncreate(value: T): void immediately copies the data from the passed\ninstance of the struct into the queue. The passed value must be an\ninstance of the class.\nEventWriters can also call clearImmediate() to immediately remove all events\nfrom the queue.",
			"parallelism#Parallelism": "EventWriters require exclusive access to their queue, and so intersect with\nreaders and writers of the same type. EventReaders do not require exclusive\naccess, and so can run in parallel with other readers of the same type."
		}
	},
	"/docs/system_parameters/queries": {
		"title": "Queries",
		"data": {
			"": "Queries allow you to find all entities that have a specific collection of\ncomponents. They're one of the most fundamental building blocks of any ECS and\nare the primary way you'll access component data. In Thyseus, queries are system\nparameters, so systems can specify as many queries as they need.",
			"accessing-data#Accessing Data": "To query for a specific component, you can provide it as the first generic of\nthe Query type. Your system will receive a query as an argument that can be\niterated over:\nHere, we're querying for all entities with the Health component. In our system\nwe iterate over each of those entities and log the current and max values; the\nyielded health value will be an instance of Health.\nThyseus re-uses component instances during iteration for performance\nreasons, so you should not grab and hold a reference to it.\nIf you'd like to access multiple components in the same query, you can use a\ntuple:\nIn this case, the query will yield [Position, Velocity] tuples. You can use\ntuples of any size to specify the components you need, but you cannot nest\ntuples.If you're copying these examples locally, you may have noticed that both pos\nand vel are typed as readonly. By default, queries only provide readonly\naccess to components. Of course, data that can only ever be read is of very\nlimited use to us.",
			"writing-data#Writing Data": "Mutable component data is as easy as wrapping your components in Mut:\nQueries can have as many mutable components as needed! While it may be tempting\nto make everything mutable just in case, you should prefer immutability when\npossible.\nAt the moment, Thyseus does not throw an error if you write data that you've\nrequested readonly. This will likely change in the future. For now,\nTypescript will help prevent these mistakes!",
			"filters#Filters": "Queries also allow you to specify that entities must have or not have specific\ncomponents without needing access to those components. These are known as\nfilters. Filters are the second argument of the Query() descriptor\ncreator, and must always be wrapped in some filter specifier.",
			"with#With": "As the name implies, this filter requires that entities have a specific\ncomponent. If they do not, the query will fail to match. With filters are\nparticularly useful for zero-sized components, which you may use to \"tag\"\nentities.\nYou can pass either a single component to With, or an array of components if\nyou want to require multiple (an \"And\" clause):",
			"without#Without": "The opposite of With, Without requires that queried entities do not have\nspecific components.",
			"or#Or": "Or filters allow more complex query logic, where entities may satisfy either\ncondition provided in order to match a query. Or can only accept two\narguments, but you may nest them as deeply as you need. The provided arguments\nmust be valid filters - With, Without, Or, or some tuple (\"And\") of those\nitems.",
			"impossible-queries#Impossible Queries": "When queries are created, they will throw an error if it is logically impossible\nfor them to match any entity. For example, the following query will throw an\nerror:\nNote that queries cannot detect if they cannot match any entity merely by\nconvention. For example, if you query for A and B but there is no\nmechanism in your application by which both A and B can be added to an\nentity, the query will not be able to detect this and no error will be thrown."
		}
	},
	"/docs/system_parameters/resources": {
		"title": "Resources",
		"data": {
			"": "Resources are world-unique data that exist for the entire lifetime of the world.\nUnlike components, they are not tied to a specific entity. Resources can\nelegantly handle things like time (frame number, delta, etc.), renderers,\ninputs, and other data that is unique to a world rather than an entity.",
			"defining-resources#Defining resources": "Resources are modeled as classes. Unlike components, they can be, but are not\nrequired to be, decorated with @struct. Resources decorated with @struct\nwill be accessible from any thread, while resources that are not will only be\naccessible on the main thread.\nWhen these resources are used by systems, they will be refering to the same\nobject (or, the same data for structs in worker threads):\nLike components, resources are readonly by default. If you'd like to mutate\na resource, you can simply wrap it in Mut:\nIf you have a type that you'd like to use as multiple resources, you can\nsimply subclass it.",
			"initializing-resources#Initializing resources": "In some cases, you may want to access your resource from any thread, but it must\nrun some initialization on the main thread. For these cases, we can implement a\nspecial initialize method that will be called when the world is built. Let's\nconsider a Keyboard resource that tracks inputs.\nHypothetically, there's no reason the state of the keyboard shouldn't be read\nfrom any thread. However, we need to set up event listeners to capture\n'keydown' and 'keyup' events, which does need to happen only on the main\nthread. Constructors must be callable from all threads, so that's not an\noption - this is the perfect use for the initialize method!\nAs you can see above, you can put any setup code you need in this method. If\nyour resource has an initialize method, it'll be called once with the world\ninitializing when that world is being built. If your setup is async, the\ninitialize method is also allowed to return a promise, which will be awaited\nbefore continuing to build the world.Resources are not required to have an initialize method, but it will be\ncalled if it exists - you cannot use this method name for something else."
		}
	},
	"/docs/system_parameters/system_resources": {
		"title": "System Resources",
		"data": {
			"": "System Resources are a variation of resources that are unique per system,\nrather than per world. This means that multiple system resources of the same\ntype can exist in the world. System resources are always considered mutable, as\nthey are owned by a single system. A system may also have multiple of the same\ntype of system resource, each containing different values:\nLike world resources, system resources are considered accessible from any thread\nif decorated by @struct and bound to the main thread otherwise. @struct\nsystem resources will have consistent values across threads, making them a good\nreplacement for mutable local closures.System resources are scoped to the system that uses them; if a system exists in\nmultiple schedules, it will always receive the same system resource! If your\nsystem needs to receive different objects in different schedules, you can\nclone that system and use the clone in one of the schedules.Apart from their scope, system resources function identically to normal\nresources, initialize and all. In fact, the same class could be used both as a\nsystem resource and as a world resource!"
		}
	},
	"/docs/system_parameters/world": {
		"title": "World Parameters",
		"data": {
			"": "On rare occasions, you may need access to the World itself. For this reason,\nThyseus also provides a World system parameter. In general, it is best to\navoid accessing the world itself - most APIs that require direct access to the\nworld are low-level and difficult to use correctly. Additionally, accessing the\nworld creates a hard sync point when multithreading - no other system can run\nwhile the world is being accessed.The most common use case for accessing the world is running a custom schedule:\nWhen your system requires access to the world, you are guaranteed to always\naccess the world from the main thread. World instances constructed in threads\ndo not have access to all data (e.g., mainthread-only resources) and do not have\nthe ability to communicate with threads other than the main thread.\nAdditionally, most world methods depend on being called only on the main thread!"
		}
	},
	"/": { "title": "Index", "data": {} },
	"/docs/advanced_patterns/custom_system_parameters": {
		"title": "Custom System Parameters",
		"data": {
			"": "Thyseus' system parameters are designed so that it is simple to write your own.\nParameters are responsible for declaring how they interact with other parameters\nand what data they need from the world - as a result, just about anything\nThyseus can do internally, you can do, too! System parameters start with\nsystem parameter descriptors.",
			"what-is-a-system-parameter-descriptor#What is a system parameter descriptor?": "As far as Thyseus is concerned, a system parameter descriptor - the items in the\nyourSystem.parameters array - is simply an object that contains the following\nfour methods:\nisLocalToThread(): boolean\nintersectsWith(other: object): boolean\nonAddSystem(builder: WorldBuilder): void\nintoArgument(world: World): any\nWe'll dive into each of these methods and what they do before getting into how\nto write our own descriptors.",
			"islocaltothread-boolean#isLocalToThread(): boolean": "This determines whether this parameter may only be accessed from the main\nthread. Descriptors should return true if the parameter is only available from\nthe main thread, and false if the parameter is available on any thread.\nUsually descriptors will either always return true or always return false, but\nsometimes this is dependent on the provided data!",
			"intersectswithother-object-boolean#intersectsWith(other: object): boolean": "This method is called with other parameter descriptors, and is used to determine\nif other parameters intersect with or are disjoint with this parameter. If\nparameters intersect (true is returned), the systems they belong to will be\nmarked as intersecting, and cannot run in parallel. If they are disjoint\n(false is returned), the systems may run in parallel.intersectsWith does not need to be symmetric; both descriptors are called\nwith each other, and if either returns true they are marked as intersecting.",
			"onaddsystembuilder-worldbuilder-void#onAddSystem(builder: WorldBuilder): void": "This method is called when a system is added by a WorldBuilder instance. It is\ncalled with the WorldBuilder that added it, and allows the descriptor to do\nwhatever it may need with the builder - anything from adding plugins to\nregistering types. For some descriptors (e.g., WorldDescriptor), this function\nis a no-op.",
			"intoargumentworld-world-any#intoArgument(world: World): any": "This method is passed the world building the system, and whatever is returned\nfrom this method will be passed to systems when they are called. This method may\nreturn anything.\nPromises returned by intoArgument(world: World): any will be awaited\nbefore systems are called!",
			"recreating-res#Recreating Res": "Let's dive into the internal implementation of ResourceDescriptor to get a\nfeel for how these methods might work.",
			"construction#Construction": "First, we'll need a class that creates our descriptor objects. For parameter\ndescriptors to work with the transformer, parameter descriptors must be\nimplemented as classes, as the transformer will try to new them.To get started with resources, we really just need to know the type (or class)\nof the resource:\nThat's a nice start! Let's try adding some descriptor methods.",
			"onaddsystem-for-resources#onAddSystem for Resources": "First, we need to know what the builder should do when it comes across this\ndescriptor. Resources in Thyseus are a first-class concept, so all we'll need to\ndo is register that we have a (potentially) new resource!\nThe builder handles deduping types, so that's it for our responsibilities. Other\ndescriptors may need to add systems to work correctly, or to register\ncomponents, or more.",
			"resource-thread-locality#Resource Thread Locality": "Resources in Thyseus are allowed to be either mainthread-only or shareable\nacross threads. Thyseus allows shared data with Structs; if a class is\ncorrectly implemented as a Struct, then we should be able to share it across\nthreads. If not, then we'll only be able to access the data from the main\nthread.So how do we know a class is a struct? Well, there's an internal utility for\nthis:\nStructs are very simple, from Thyseus' perspective - classes (functions) with\nstatic size and alignment properties.Okay! Now to use this in our descriptor class:",
			"parameter-intersection#Parameter intersection": "Now we've made it to a trickier concept - parameter intersection. We need to\nknow if parameters intersect to determine whether systems may run in parallel.\nIn general, it is safe for two (or more) systems to read the same data at the\nsame time. However, if a system writes data, it is no longer safe for a\ndifferent system to read or write that data.But wait - we don't even know if we're reading or writing data! We'll need to\nrevise our constructor a little bit to make sure we know what we're doing with\nthe data we access.There's a number of approaches we could take here. One would be to accept a\nsecond argument, perhaps a boolean indicating whether our data should be\nreadonly or not. Another would be to split our descriptor into two, perhaps a\nResourceDescriptor and MutableResourceDescriptor. Either of these would be a\nperfectly valid approach - however, Thyseus already includes a Mut<T> utility\nfor queries to denote whether they access a component mutably or not. For the\nsake of a consistent API, we'll mirror that for resources. Our new constructor\nthen might look like this:\nGreat! Now we know if we're reading or writing data.For intersectsWith, we really don't know anything about the values we'll\nreceive. It could be a first-party parameter descriptor, or a different third\nparty descriptor. Internally, we generally choose to treat these as unknown,\nbut since they'll always be descriptors, you could type them as object (or\neven a slightly more narrow Descriptor type).So, first we need to know if the other descriptor is a resource descriptor. If\nit isn't, there's no risk of intersection - or strictly speaking, we will place\nthe responsibility of determining this intersection on the other descriptor.\nNext, we only run the risk of intersection if we're accessing the same data. And\nlast, we only intersect if either this descriptor or the other is accessing data\nmutably. In code:\nRemember that intersectsWith does not need to be symmetric. Both descriptors\nwill call this method with the other, and if either returns true, then the\nparameters intersect. For example, the WorldDescriptor implements this method\nlike so:\nBecause we trust that WorldDescriptor correctly implements its own\nintersectsWith method (it always intersects), ResourceDescriptor doesn't\nneed to concern itself with how it interacts with WorldDescriptor or any other\ndescriptor.",
			"turning-parameters-into-arguments#Turning Parameters Into Arguments": "The last step is turning your parameter descriptor into an argument. For this,\nwe receive the world as an argument, and will usually return some piece of its\ninternal state. In the case of resources, it's pretty easy to get that data!\nAnd perfect - you now have a fully functioning custom system parameter! Here's\nthe full code:\nNext, we'll go into how to let the transformer recognize your parameter.",
			"transforming-system-parameters#Transforming System Parameters": "The transformer plugin accepts config that allows you to register additional\nsystem parameter types for it to recognize. Using the config, we can tell the\ntransformer how to handle our custom system parameters.\nThe key in the SystemParameterMap refers to the name of the type we'd like\nthe transformer to recognize. The descriptorName is the named import it\nwill be imported as. importPath is the location to import it from. For system\nparameters to work correctly, they must be able to be imported from a\nnon-relative path; how you handle this is dependent on your bundler and how\nyou'd like to handle import aliasing.For the case of Res, this looks something like:\nWe tell the plugin that we'd like it to recognize types named Res, and that it\nwill need to import { ResourceDescriptor } from 'thyseus/descriptors'; in\norder to use that system parameter. When the transformer sees a system with that\ntype, it'll generate the necessary code to make your systems work.\nYou may have noticed that Res as provided by Thyseus is generic - in fact, it\nhas to be in order to work correctly! When system parameters accept generics,\nthose are passed as arguments to the parameter descriptor function.\nIt is up to you to validate that the types provided to your system parameter and\nthe arguments provided to your descriptor are correct, both at the type level\nand at runtime."
		}
	},
	"/docs/multithreading/rules": {
		"title": "Rules of Multithreading",
		"data": {
			"": "Thyseus strives to make multithreading trivially easy without introducing new or\nunpredictable behavior. In particular, it aims to require few, if any changes\nto your code for you to enjoy the benefits of running your code on multiple\nthreads, or to switch back to singlethreaded execution if necessary.Nevertheless, there are still a few rules for multithreading to work.It is generally suggested that you follow all of these rules (with the exception\nof the first) regardless of whether you intend to use multithreading, so that\nyou may opt-in to multithreading with ease and for the simplicity and\nmaintainability of your own code.",
			"module-type-workers-and-sharedarraybuffers-are-required#Module-Type Workers and SharedArrayBuffers are required.": "Thyseus' multithreading model is centered around these two technologies - if\neither of these is not available in your target environment for some reason,\nthen you unfortunately will not be able to leverage Thyseus' multithreading\ncapabilities.",
			"the-order-that-systems-and-plugins-are-added-in-must-be-stable#The order that systems and plugins are added in must be stable": "Thyseus uses the registration order of systems, components, and resources in\norder to identify them between threads. As a result, passing anything other than\nimport.meta.url as the second argument for World.new() or randomizing the\norder systems or plugins are registered in will almost always result in\nincorrect behavior.\nIt is permissible to conditionally register systems or plugins only if the\nconditions are consistent between threads.",
			"the-module-the-world-is-built-in-should-not-unconditionally-run-worldupdate#The module the world is built in should not (unconditionally) run world.update": "world.update() is designed to be called on the main thread, and internally it\ncommunicates with other threads to run systems in parallel. Calling this method\non multiple threads will have unpredictable results.",
			"the-module-the-world-is-built-in-or-any-module-it-imports-should-not-have-top-level-references-to-context-specific-apis#The module the world is built in, or any module it imports, should not have top-level references to context-specific APIs.": "Workers run in a different context than the main thread, so some APIs available\non the main thread are not available in workers. As a result, there should be no\ntop-level references (i.e., not contained in a function) to window-only objects\nin the module the world is built in or any module it imports. Resources can\nsafely access any main thread APIs in their initialize method, and\nthread-local resources can refer to window-only objects in their\nconstructor/methods.Technically, if you know a system is thread-local, you may also include\nwindow-only objects in system bodies, but this is generally not recommended.",
			"systems-must-not-rely-on-closures-over-mutable-local-variables#Systems must not rely on closures over mutable local variables": "This requirement is the most likely to require changes to your code. Any system\nthat is not bound to the main thread can run on any thread, any frame. As a\nresult, anything a system mutates from the surrounding scope will not have\npredictable values, unless that system is bound to the main thread (and even\nstill, this is not recommended).Constants will work just fine, so long as they do not depend on script execution\ncontext (like accessing document).\nIf you need data that's \"local\" to a system and can safely be mutated, you may\nwant system resources."
		}
	}
}
