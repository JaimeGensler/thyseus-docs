---
title: Worlds
---

import { Callout } from ':ui';

# Worlds

Worlds contain your entities and components, and are responsible for executing
systems. Every world is independent and self-contained; systems and types can be
used by multiple worlds, but data belongs to a single world. Many applications
only need a single world - particularly starting out - but sometimes multiple
may be the right choice.

## Adding Systems

Worlds start with a WorldBuilder and the `World.new()` method. The
`WorldBuilder` is responsible for registering all systems and types that will be
used in a particular World; all systems and types a world will use **must be
registered**. Let's create one now:

```ts
import { World } from 'thyseus';

const myWorldBuilder = World.new();
```

Fortunately, you typically only need to worry about adding systems to your
world; when you add a system, it can (usually) handle registering the types it
needs! Let's add a system now:

```ts {2,4}
import { World } from 'thyseus';
import { Inventory, IsPlayer } from './components';

function inventorySystem(query: Query<Inventory, With<IsPlayer>>) {}

const myWorldBuilder = World.new().addSystems(inventorySystem);
```

By adding this system, we've also registered the `Inventory` & `IsPlayer`
components.

Most methods on `WorldBuilder`s return the `WorldBuilder` itself, so they can be
chained. Let's add a few more systems!

```ts {5-7}
import { World } from 'thyseus';
import { move, draw, handleInput } from './systems';

const myWorldBuilder = World.new()
	.addSystems(move)
	.addSystems(draw)
	.addSystems(handleInput);
```

Of course, it's called `addSystems` for a reason:

{/* prettier-ignore */}
```ts {5}
import { World } from 'thyseus';
import { move, draw, handleInput } from './systems';

const myWorldBuilder = World.new()
	.addSystems(move, draw, handleInput);
```

## Building A World

When you've added all the systems you'd like, you can build your world and start
executing systems. We can use the `build()` method for this, which returns a
promise that resolves with your completed world. Let's try it now with a system
that just calls `console.log`:

{/* prettier-ignore */}
```ts {9}
import { World } from 'thyseus';

function helloSystem() {
	console.log('Hello, world!')
}

const myWorld = await World.new()
	.addSystems(helloSystem)
	.build();
```

<Callout type="note">
	Top-level await is a convenient way to handle the promise returned by
	`build()` - especially when starting out - but is not required.
</Callout>

Cool, but just building a world doesn't start your systems. Let's set up a loop
to call our system!

{/* prettier-ignore */}
```ts {11-15}
import { World, DefaultSchedule } from 'thyseus';

function helloSystem() {
	console.log('Hello, world!')
}

const myWorld = await World.new()
	.addSystems(helloSystem)
	.build();

async function loop() {
	await myWorld.runSchedule(DefaultSchedule)
	requestAnimationFrame(loop)
}
loop()
```

Here, we're using the `runSchedule` method - we'll cover schedules next, but for
now all you need to know is systems are added to the `DefaultSchedule` when you
use `addSystems`, and calling `runSchedule` runs all systems in a schedule.

If you look in your browser's log, you should see a whole lot of
`"Hello, world!"`s!

## Schedules

Worlds can contain multiple groups of systems called **schedules**. Schedules
run all the systems they contain together before execution of other schedules
may occur. However, schedules may contain systems that execute _other_
schedules.

Schedules have a number of different uses - they can be used to create a group
of systems that only runs when your app starts, or when tearing down, or systems
that need to run at a fixed rate!

By default, Thyseus provides two schedules - the `DefaultSchedule`, which
systems are added to when calling `addSystems`, and the `StartSchedule`.

### `StartSchedule`

The `StartSchedule` is intended to control the execution of all other schedules.
It is run when `world.start()` is called. Let's rewrite the above example using
this:

{/* prettier-ignore */}
```ts {11-15}
import { World, DefaultSchedule, StartSchedule } from 'thyseus';

function helloSystem() {
	console.log('Hello, world!');
}

function startSystem(world: World) {
	async function loop() {
		await world.runSchedule(DefaultSchedule);
		requestAnimationFrame(loop);
	}
	loop();
}

const myWorld = await World.new()
	.addSystems(helloSystem)
	.addSystemsToSchedule(StartSchedule, startSystem)
	.build();

myWorld.start();
```

This is essentially the same as the previous example, but now we've localized
all our startup logic to our `startSystem`. Using `world.start()` comes with the
added bonus that it can safely be called from any thread (unlike
`world.runSchedule`, which must only be called from the main thread).

## Dependencies

By default, Thyseus makes no guarantees about the order in which systems will be
executed - it may be completely stable, or it could change every execution. If
one of your system needs to run _before_ or _after_ another system, you can
specify **system dependencies** using the `run` function.

```ts {9,10}
import { World, run } from 'thyseus';
function systemA() {}
function systemB() {}
function systemC() {}
function systemD() {}

const myWorld = await World.new()
	.addSystems(
		run(systemA).after(systemB),
		run(systemB).before(systemC).after(systemD),
		systemC,
		systemD,
	)
	.build();
```

Contradictory dependencies like `run(A).after(A)` or
`run(A).after(B), run(B).after(A)` will cause an error to be thrown when the
world is built.

## Plugins

Plugins are simply functions that accept a `WorldBuilder` instance and register
systems and types on that `WorldBuilder`. Plugins give you the flexibility to
change the implementation details of a piece of functionality without changing
the external API.

```ts
import { CoreSchedule, World } from 'thyseus';
import {
	applyForces,
	detectCollisions,
	resolveCollisions,
} from './physicsSystems';

function myPlugin(builder: WorldBuilder) {
	builder.addSystems(
		CoreSchedule.FixedTimeStep,
		applyForces,
		detectCollisions,
		resolveCollisions,
	);
}

const world = await World.new().addPlugin(myPlugin).build();
```
