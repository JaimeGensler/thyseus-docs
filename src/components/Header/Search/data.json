{
	"/docs/core_concepts/components": {
		"title": "Components",
		"data": {
			"": "A component is a self-contained unit of data that belongs to an entity. An\nentity can have 0 or more components and can add or remove components throughout\nthe course of its life. Components can describe any data belonging to an entity,\nsuch as Transform, Health, Inventory, IsPlayer, and anything else you\nneed.",
			"writing-components#Writing Components": "Components are modeled as normal Javascript classes - they may contain fields of\nany type, as well as constructors and methods.\nThyseus identifies the types of components by looking at the object's\ninherent constructor property. As a result, plain Javascript objects\ncannot be used as components!\nHere we've defined an isolated component that determines an entity's health. Of\ncourse, there's nothing stopping current from exceeding max, which we likely\ndo not want. This is a great case for methods:\nWe've converted the max and current properties to be # private, requiring\nconsumers to use the heal() and takeDamage() methods. This protects our\nfields from unexpected combinations while keeping our code dry, localized, and\neasily testable.Components can define constructors and be extended as needed",
			"tag-components#Tag Components": "In some cases, you may want to add a \"tag\" to an entity (e.g., IsPlayer) but\nhave no additional data associated with that component. While normal components\nwork just fine for this, Thyseus allows you to create \"tag\" components -\nsometimes referred to as \"zero-sized types\" (ZSTs)."
		}
	},
	"/docs/core_concepts/entities": {
		"title": "Entities",
		"data": {
			"": "Entities can represent any concrete \"thing\" in your game world; players,\nenemies, items, the game level itself, even parts of the UI - all entities.\nConceptually, an entity is simply an empty container for any number of\ncomponents, and contains no special properties, data, or meaning on its own.\nIn practice, an entity is nothing more than an integer id.Because entities contain no inherent data or meaning, it's not particularly\ncommon to deal with them directly; instead, you'll usually interact with\ncomponents, the data that belongs to an entity.",
			"creating-entities#Creating Entities": "Worlds take responsibility for creating new entities. We'll cover worlds and\nthe systems more in the future - for now, we'll write some very simple systems\nto show you how to work with entities!\nThis is a basic system that accepts the World. World.p.spawn() creates a new\nEntity object and returns it. You can then add (or remove) components from\nthat entity!Entity creation and changes are not handled immediately. When you spawn()\nan entity or change its components, these changes are added to a queue, which\nis processed later - by default, after a schedule finishes executing. Changes to\nentities (including spawning and despawning) are not observable until after\nthis queue of changes has been processed!",
			"accessing-entities#Accessing Entities": "Every entity possesses an Entity component. This component allows you to\naccess the entity's id, enqueue changes to it, check what components it has, and\ncan be queried for in systems (queries will be covered more later, too!).\nEvery Entity's Entity component is unique - if you'd like to access that\nentity later, you can hold onto the object. It also contains an isAlive field\nthat can be used to check liveliness at any point. Once the entity has been\ndespawned, isAlive will be false.",
			"destroying-entities#Destroying Entities": "Of course, not all entities will live forever. You can use the Entity\ncomponent to queue an entity for destruction:"
		}
	},
	"/docs/core_concepts/systems": {
		"title": "Systems",
		"data": {
			"": "Systems are the functionality of an ECS application. Most often, systems are\nused to query for entities with particular components, but they can also be used\nto spawn entities, handle events, draw to canvases, serialize data & write it to\nfiles, or anything else you might need them to do.",
			"defining-systems#Defining Systems": "Systems being functionality, it's only natural for them to be functions! A\nfunction is a system if it accepts only \"system parameters\". They may accept\nzero, one, or many parameters - even multiple of the same type of parameter! So\nlong as every parameter is a system parameter, it's a system.We've already seen a couple simple systems - let's start by revisiting those.",
			"basic-spawning-system#Basic Spawning System": "In the entities section, we saw a system that used the World to spawn\nentities. Worlds are both the entrypoint for an app and one of the built-in\nsystem parameters, and is responsible for spawning entities. Now that we know\nabout components, let's try spawning an entity and adding a component to it:\nWhen this function runs, it will be called with the World object, which we can\ndo whatever we need with!",
			"basic-query-system#Basic Query System": "Next, let's look into queries more - they're probably the most used parameter!\nThere's a lot more going on here, so let's work through it piece by piece.\nFirst, we define a system that accepts one argument - a Query. This query will\nlook for entities that have both a Position and a Velocity component - every\nentity that has at least both of these components will match this query.\nIn the function body, we're iterating over the query - this means we're getting\nthe Position and Velocity components for every entity the query matches. For\neach entity, we're simply logging the position and velocity. In future examples,\nwe'll do a lot more!",
			"other-system-parameters#Other System Parameters": "Queries and the world are just two of the system parameters Thyseus provides out\nof the box; your systems can get much more complex, using multiple queries,\naccessing resources, or reading & writing events. Later sections will cover all\nof the system parameters in depth - and if you need system parameters not\nprovided by Thyseus, you can even\ncreate your own.",
			"system-transformation#System Transformation": "The transformer takes care of making sure that systems receive the arguments\nthey need. It comes with a couple usage caveats.\nOnly function declarations and functions in variable initialization are\ntransformed. Function expressions passed inline to other functions won't\nbe transformed, but you can always provide parameters manually.\nType aliases (including import aliases) are not permitted; simple\naliases (type MyQuery = Query<...>), or \"namespaced\" types\n(Thyseus.Query) will not be transformed.\nFunctions with rest parameters will not be transformed, even if the\nparameters are typed as a tuple containing only valid system parameters.\nImport classes, not just types. When using class types, the transformer\nassumes the actual class is in scope; if you get a reference error, it's\nprobably this.\nSystems can't be generic. Of course, you can still create generic \"base\"\nfunctions and call them in systems with your non-generic data.\nFunctions that accept only system parameters will have a parameters\nproperty added, even if they aren't used as systems. This is more-or-less\nharmless; you can ignore or //thyseus-ignore it - up to you!"
		}
	},
	"/docs/core_concepts/worlds": {
		"title": "Worlds",
		"data": {
			"": "Worlds contain your entities and components, and are responsible for executing\nsystems. Every world is independent and self-contained; systems and types can be\nused by multiple worlds, but data belongs to a single world.",
			"adding-systems#Adding Systems": "Worlds can be constructed with new World(config). They may add components,\nevents, and even systems at any point.\nThe addSystems() method return the World itself so it can be chained. Let's\nadd a few more systems!\nYou'll notice we're calling .prepare() here - after adding all the systems\nyou'd like to get started, you need to prepare the world to run. Some systems\nrequire some async setup, so this will return a promise. Any time you add new\nsystems to the world, you'll need to prepare() it again.\nTop-level await is a convenient way to handle the promise returned by\nprepare(), but is not required.\nLet's also setup a loop to run your world!\nHere, we're adding an event listener to the world's \"start\" event. When\nstart is emitted, we're establishing a loop that runs the default schedule\n(all systems added with addSystems()) once per frame.If you look in your browser's log, you should see a whole lot of\n\"Hello, world!\"s!",
			"schedules#Schedules": "Worlds can contain multiple groups of systems called Schedules. Schedules\nhave a number of different uses - creating groups of systems that only runs when\nyour app starts, or when tearing down, or systems that need to run at a fixed\nrate like physics systems.Thyseus provides the Schedule class which stores systems and their arguments\nand handles running them. You can create your own schedules by extending this\nclass - e.g. class PhysicsSchedule extends Schedule {}. When calling\naddSystems(), you must specify a schedule to add systems to.",
			"plugins#Plugins": "Plugins are simply functions that accept a World and register systems and\ntypes on that World. Plugins give you the flexibility to change the\nimplementation details of a piece of functionality without changing the external\nAPI."
		}
	},
	"/docs/getting_started/installation_and_setup": {
		"title": "Installation & Setup",
		"data": {
			"": "To get started with Thyseus, install the core library:",
			"transformer-setup#Transformer Setup": "The official Thyseus transformer is available as a (Vite-compatible)\nRollup plugin. If you'd like support to be added\nfor your bundler of choice, please file a\nticket!\nThyseus makes use of a Typescript transformer to provide better DX. If you're\nnot using the transformer, you'll need to review\n\"Systems Without the Transformer.\"\nThe transformer also requires Typescript; if you don't have experience with\nTypescript, it's recommended that you\nget familiar with the basics\nbefore starting with Thyseus.\nInstall...\n...and configure.\nNote that thyseusPlugin() must appear before typescript() in order to work, as the plugin transpiles Typescript to Typescript.\nInstall...\n...and configure.",
			"development-vs-production-builds#Development vs. production builds": "Thyseus uses esm-env to determine\nwhether you're building your app for development or production. Dev builds have\na number of additional correctness checks and validations that help you make\nsure your app works correctly and that thrown errors are easily debuggable.\nThese checks come at the cost of speed, so for production builds these checks\nare stripped out. As long as you're using a modern bundler, this should happen\nautomatically."
		}
	},
	"/docs": {
		"title": "Introduction",
		"data": {
			"": "Thyseus is an Entity Component System (ECS) framework written in Typescript.\nTaking much inspiration from Bevy, it aims to provide\na best-in-class developer experience without sacrificing performance.ECS is a data-oriented design approach to development typically found in games\nthat promotes modularity and reusability by separating data and behavior. It\nconsists of entities, which are unique identifiers; components which are\nplain data; and systems, which operate on data. For a good introduction to\nthe paradigm, read the ECS FAQ by\nSander Mertens.Thyseus is a powerful foundation for you to build your own complex applications\non that remains deeply configureable and composeable. It supports a number of\nfeatures out of the box, including:\nEffortless integration with third-party libraries like\nthree.js.\nArchetypal storage for lean memory use and cache-friendly iteration.\nComplex queries with filters like Maybe, And, Or, With, and\nWithout.\nFirst class support for Resources (singletons) and Events.\nBoilerplate-free and safety-first worker thread support - no eval()!\nDeeply customizable execution logic for easy handling of patterns like fixed\nupdates.\nLet's dive into it!"
		}
	},
	"/docs/reference/glossary": {
		"title": "Glossary",
		"data": {
			"struct#Struct": "In languages like C and Rust, structs are similar to Javascript objects, but\ntheir keys and the types of their values are known at compile-time and can be\noptimized as a result. Structs in Thyseus are intended to emulate these structs,\nand so their size must be constant.",
			"resources#Resources": "World-unique data. Some ECS libraries use singletons to model world-unique data\n(components that only exist on one entity). Because this pattern of needing\nworld-unique data is so common, Thyseus treats it as a first-class concept.\nResources are just classes - if they correctly implement the requirements of\nStructs, they can be shared across threads.",
			"system-relationships#System Relationships": "In a multithreaded environment, systems can have one of two relationships to one\nanother - Disjoint or Intersecting. When two systems are Disjoint, it\nmeans that neither system will write data that the other is trying to read or\nwrite. Systems that read (and only read) the same data remain disjoint. Disjoint\nsystems may execute in parallel. Intersecting systems are the opposite of\nDisjoint systems - one (or both) of the systems writes to data that the other\nsystem must also read or write. Intersecting systems cannot execute in parallel.In general, you don’t have to think about whether systems are disjoint or\nintersecting - Thyseus can automatically determine the relationship between\nevery system in your world. However, it is important to make sure you’re only\nrequesting write access when your system needs it, or in certain cases to break\na system into multiple smaller systems if it requires mutable access to a lot of\ndifferent data. The page on\nusing multiple threads goes into\ndetail about getting better multithreaded performance, and the guide to\ncustom system parameters explains\nmore how intersection is determined.",
			"dependencies#Dependencies": "Dependencies are requirements that must be met before a system can run. A system\ncan specify that certain systems must before it may run as well.",
			"zero-sized-type-zst#Zero-Sized Type (ZST)": "Zero-sized type. This refers to structs that are used as markers (or tags, or\nflags) for entities, and whose storage does not take up any space.",
			"archetype--table#Archetype / Table": "There are numerous approaches to writing an ECS - Thyseus uses an\narchetypal\ndesign.An entity's archetype refers to the collection of components (including\nZSTs) that entity possesses. In Thyseus, this is represented as a bigint.Component data is stored in tables, where each column is the data for a\nspecific component type, and each row represents an entity and its unique data.\nTables do not include columns for ZSTs because ZSTs contain no data. Entities\nwith the same archetype are (usually) stored in the same table, but in some ECS\nimplementations entities in the same table can have different archetypes.This strategy generally makes iterating over entities extremely cache-friendly\nat the cost of making changes to an entity's archetype - a table move - a bit\nmore expensive."
		}
	},
	"/docs/system_parameters/events": {
		"title": "Events",
		"data": {
			"": "Events allow you to run logic in response to something that happened in your\ngame, and can be used as a means of cross-system communication. Events are\ninstances of classes and live in a queue of other events of the same type. New\nevents can be pushed to the queue with EventWriter<T>, and events in the queue\ncan be read with EventReader<T>.Events have no set lifetime - they will persist until the queue is manually\ncleared. Writers can call the clear() method to remove all events from the\ncurrent queue, or you can add the clearAllEventQueues system to your schedule!",
			"eventreader#EventReader": "EventReaders are responsible for reading data from the event queue.They can be iterated over in a for...of loop, and will yield instances of the\nevent type. You can also check their length to determine the number of\nelements in the queue.",
			"eventwriter#EventWriter": "EventWriter inherits all functionality of EventReader, and is also\nresponsible for adding events to the queue. You can add events to the queue with\ncreate(value: T): void, which simply pushes the provided value to the queue.\nThe passed value must be an instance of the class.EventWriters can also call clearImmediate() to immediately remove all events\nfrom the queue."
		}
	},
	"/docs/system_parameters/queries": {
		"title": "Queries",
		"data": {
			"": "Queries allow you to find all entities that have a specific collection of\ncomponents. They're one of the most fundamental building blocks of any ECS and\nare the primary way you'll access component data. In Thyseus, queries are system\nparameters, so systems can specify as many queries as they need.",
			"accessing-data#Accessing Data": "To query for a specific component, you can provide it as the first generic of\nthe Query type. Your system will receive a query as an argument that can be\niterated over:\nHere, we're querying for all entities with the Health component. In our system\nwe iterate over each of those entities and log the current and max values; the\nyielded health value will be an instance of Health.If you'd like to access multiple components in the same query, you can use a\ntuple:\nIn this case, the query will yield [Position, Velocity] tuples. You can use\ntuples of any size to specify the components you need, but you cannot nest\ntuples.You may also wrap your components in Readonly<T> if you'd like to narrow the\ntypes further.",
			"optional-access#Optional Access": "If you'd like to access data only if it exists, but still have queries match if\nnot, you can use Maybe<T> modifiers. These will yield either the queried\ncomponent or undefined.",
			"filters#Filters": "Queries also allow you to specify that entities must have or not have specific\ncomponents without needing access to those components. These are known as\nfilters. Filters are the second argument of the Query descriptor\ncreator, and must always be wrapped in some filter specifier.",
			"with#With": "As the name implies, this filter requires that entities have a specific\ncomponent. If they do not, the query will fail to match. With filters are\nparticularly useful for zero-sized components, which you may use to \"tag\"\nentities.\nYou can pass either a single component to With, or an array of components if\nyou want to require multiple (an \"And\" clause):",
			"without#Without": "The opposite of With, Without requires that queried entities do not have\nspecific components.",
			"or#Or": "Or filters allow more complex query logic, where entities may satisfy either\ncondition provided in order to match a query. Or can only accept two\narguments, but you may nest them as deeply as you need. The provided arguments\nmust be valid filters - With, Without, Or, or some tuple (\"And\") of those\nitems.",
			"impossible-queries#Impossible Queries": "When queries are created, they will throw an error if it is logically impossible\nfor them to match any entity. For example, the following query will throw an\nerror:\nNote that queries cannot detect if they cannot match any entity merely by\nconvention. For example, if you query for A and B but there is no\nmechanism in your application by which both A and B can be added to an\nentity, the query will not be able to detect this and no error will be thrown."
		}
	},
	"/docs/system_parameters/resources": {
		"title": "Resources",
		"data": {
			"": "Resources are world-unique data that exist for the entire lifetime of the world.\nUnlike components, they are not tied to a specific entity. Resources can\nelegantly handle things like time (frame number, delta, etc.), renderers,\ninputs, and other data that is unique to a world rather than an entity.",
			"defining-resources#Defining resources": "Resources are classes:\nAll systems that use the same resource type refer to the same object.\nLike components, resources can be wrapped in Readonly if you'd like to narrow\nthe type.\nResources must either implement a static fromWorld() {} method, be\nconstructable with no arguments, or be directly inserted into the world with\nWorld.p.insertResource().\nIf you'd like to use the same type for multiple resources, you can simply\nsubclass it.",
			"initializing-resources#Initializing Resources": "If you'd like your resources to be automatically created by the world, you can\nimplement the static fromWorld() {} method that will be called when schedules\nare prepared. This method will be passed the world, and so can insert\nadditional resources or event listeners. This method can also simply return an\ninstance of the class.fromWorld() must return either an instance of the resource you'd like to\ncreate, or a promise that resolves to that instance.",
			"local-resources#Local Resources": "Local Resources or \"System Resources\" are a variation of resources that are\nunique per system, rather than per world. They can typically be used in place\nof closures over module-scope variables (although module-scope variables are\nfine, too!). Systems can also have multiple local resources of the same type,\nand each will be unique:\nApart from their scope, system resources function identically to normal\nresources; the same class could be used both as a system resource and as a world\nresource."
		}
	},
	"/docs/system_parameters/threads": {
		"title": "Threads",
		"data": {
			"": "Threads and parallelism is an advanced topic. This page only outlines the\nAPI we expose to make multithreading easier, and does not cover how to\ncorrectly and safely make use of threads. Be sure you understand why, when,\nand how you might use parallelism before continuing!\nThreads can be used to offload certain tasks to another Javascript context,\nwhich will execute in parallel with the main thread. This can be used to\nhandle CPU-intensive work or to offload non-essential tasks without blocking the\nmain thread.Thyseus's thread abstraction behaves identically to the default behavior of web\nworkers; data sent between threads is copied using\nstructured cloning\nwhen sent. The only exception to this is SharedArrayBuffer objects, which are\nalways shared.",
			"expose#expose()": "To expose functions that to the main thread that can be called in the worker\nthread, you can pass an object to the expose() function. expose() will setup\nevent listeners for every function in the provided object before returning the\nprovided object. For type help, you should make the return of expose() the\ndefault export of your worker modules; Thread<T> uses this export to\ndetermine what functions can be called in the worker and the number & types of\ntheir arguments.",
			"threadt#Thread<T>": "The Thread<T> class is an abstraction over web workers that creates a\npromise-based wrapper over messages and handles formatting data for worker\nthreads using expose().Exposed worker thread functions can be called from the main thread using\nThread.p.call():\ncall() may be called multiple times without waiting for the previous promises\nto resolve, and does not have to be awaited within the system itself!"
		}
	},
	"/docs/system_parameters/world": {
		"title": "World Parameters",
		"data": {
			"": "On occasion, you may need access to the World itself. For this reason, Thyseus\nalso provides a World system parameter. In general, it is best to avoid\naccessing the world itself - most APIs that require direct access to the world\nare low-level and difficult to use correctly. Additionally, accessing the world\ncreates a hard sync point when multithreading - no other system can run while\nthe world is being accessed.All data in the world is public.The most common use case for accessing the world is running a custom schedule:\nWhen your system requires access to the world, you are guaranteed to always\naccess the world from the main thread. World instances constructed in threads\ndo not have access to all data (e.g., mainthread-only resources) and do not have\nthe ability to communicate with threads other than the main thread.\nAdditionally, most world methods depend on being called only on the main thread!"
		}
	},
	"/docs/advanced_patterns/custom_system_parameters": {
		"title": "Custom System Parameters",
		"data": {
			"": "Thyseus' system parameters are designed so that it is simple to write your own.\nParameters are responsible for declaring how they interact with other parameters\nand what data they need from the world - as a result, just about anything\nThyseus can do internally, you can do, too! System parameters start with\nsystem parameter descriptors.",
			"what-is-a-system-parameter-descriptor#What is a system parameter descriptor?": "As far as Thyseus is concerned, a system parameter descriptor - the items in the\nyourSystem.parameters array - is simply an object that contains the following\nfour methods:\nisLocalToThread(): boolean\nintersectsWith(other: object): boolean\nonAddSystem(builder: WorldBuilder): void\nintoArgument(world: World): any\nWe'll dive into each of these methods and what they do before getting into how\nto write our own descriptors.",
			"islocaltothread-boolean#isLocalToThread(): boolean": "This determines whether this parameter may only be accessed from the main\nthread. Descriptors should return true if the parameter is only available from\nthe main thread, and false if the parameter is available on any thread.\nUsually descriptors will either always return true or always return false, but\nsometimes this is dependent on the provided data!",
			"intersectswithother-object-boolean#intersectsWith(other: object): boolean": "This method is called with other parameter descriptors, and is used to determine\nif other parameters intersect with or are disjoint with this parameter. If\nparameters intersect (true is returned), the systems they belong to will be\nmarked as intersecting, and cannot run in parallel. If they are disjoint\n(false is returned), the systems may run in parallel.intersectsWith does not need to be symmetric; both descriptors are called\nwith each other, and if either returns true they are marked as intersecting.",
			"onaddsystembuilder-worldbuilder-void#onAddSystem(builder: WorldBuilder): void": "This method is called when a system is added by a WorldBuilder instance. It is\ncalled with the WorldBuilder that added it, and allows the descriptor to do\nwhatever it may need with the builder - anything from adding plugins to\nregistering types. For some descriptors (e.g., WorldDescriptor), this function\nis a no-op.",
			"intoargumentworld-world-any#intoArgument(world: World): any": "This method is passed the world building the system, and whatever is returned\nfrom this method will be passed to systems when they are called. This method may\nreturn anything.\nPromises returned by intoArgument(world: World): any will be awaited\nbefore systems are called!",
			"recreating-res#Recreating Res": "Let's dive into the internal implementation of ResourceDescriptor to get a\nfeel for how these methods might work.",
			"construction#Construction": "First, we'll need a class that creates our descriptor objects. For parameter\ndescriptors to work with the transformer, parameter descriptors must be\nimplemented as classes, as the transformer will try to new them.To get started with resources, we really just need to know the type (or class)\nof the resource:\nThat's a nice start! Let's try adding some descriptor methods.",
			"onaddsystem-for-resources#onAddSystem for Resources": "First, we need to know what the builder should do when it comes across this\ndescriptor. Resources in Thyseus are a first-class concept, so all we'll need to\ndo is register that we have a (potentially) new resource!\nThe builder handles deduping types, so that's it for our responsibilities. Other\ndescriptors may need to add systems to work correctly, or to register\ncomponents, or more.",
			"resource-thread-locality#Resource Thread Locality": "Resources in Thyseus are allowed to be either mainthread-only or shareable\nacross threads. Thyseus allows shared data with Structs; if a class is\ncorrectly implemented as a Struct, then we should be able to share it across\nthreads. If not, then we'll only be able to access the data from the main\nthread.So how do we know a class is a struct? Well, there's an internal utility for\nthis:\nStructs are very simple, from Thyseus' perspective - classes (functions) with\nstatic size and alignment properties.Okay! Now to use this in our descriptor class:",
			"parameter-intersection#Parameter intersection": "Now we've made it to a trickier concept - parameter intersection. We need to\nknow if parameters intersect to determine whether systems may run in parallel.\nIn general, it is safe for two (or more) systems to read the same data at the\nsame time. However, if a system writes data, it is no longer safe for a\ndifferent system to read or write that data.But wait - we don't even know if we're reading or writing data! We'll need to\nrevise our constructor a little bit to make sure we know what we're doing with\nthe data we access.There's a number of approaches we could take here. One would be to accept a\nsecond argument, perhaps a boolean indicating whether our data should be\nreadonly or not. Another would be to split our descriptor into two, perhaps a\nResourceDescriptor and MutableResourceDescriptor. Either of these would be a\nperfectly valid approach - however, Thyseus already includes a Mut<T> utility\nfor queries to denote whether they access a component mutably or not. For the\nsake of a consistent API, we'll mirror that for resources. Our new constructor\nthen might look like this:\nGreat! Now we know if we're reading or writing data.For intersectsWith, we really don't know anything about the values we'll\nreceive. It could be a first-party parameter descriptor, or a different third\nparty descriptor. Internally, we generally choose to treat these as unknown,\nbut since they'll always be descriptors, you could type them as object (or\neven a slightly more narrow Descriptor type).So, first we need to know if the other descriptor is a resource descriptor. If\nit isn't, there's no risk of intersection - or strictly speaking, we will place\nthe responsibility of determining this intersection on the other descriptor.\nNext, we only run the risk of intersection if we're accessing the same data. And\nlast, we only intersect if either this descriptor or the other is accessing data\nmutably. In code:\nRemember that intersectsWith does not need to be symmetric. Both descriptors\nwill call this method with the other, and if either returns true, then the\nparameters intersect. For example, the WorldDescriptor implements this method\nlike so:\nBecause we trust that WorldDescriptor correctly implements its own\nintersectsWith method (it always intersects), ResourceDescriptor doesn't\nneed to concern itself with how it interacts with WorldDescriptor or any other\ndescriptor.",
			"turning-parameters-into-arguments#Turning Parameters Into Arguments": "The last step is turning your parameter descriptor into an argument. For this,\nwe receive the world as an argument, and will usually return some piece of its\ninternal state. In the case of resources, it's pretty easy to get that data!\nAnd perfect - you now have a fully functioning custom system parameter! Here's\nthe full code:\nNext, we'll go into how to let the transformer recognize your parameter.",
			"transforming-system-parameters#Transforming System Parameters": "The transformer plugin accepts config that allows you to register additional\nsystem parameter types for it to recognize. Using the config, we can tell the\ntransformer how to handle our custom system parameters.\nThe key in the SystemParameterMap refers to the name of the type we'd like\nthe transformer to recognize. The descriptorName is the named import it\nwill be imported as. importPath is the location to import it from. For system\nparameters to work correctly, they must be able to be imported from a\nnon-relative path; how you handle this is dependent on your bundler and how\nyou'd like to handle import aliasing.For the case of Res, this looks something like:\nWe tell the plugin that we'd like it to recognize types named Res, and that it\nwill need to import { ResourceDescriptor } from 'thyseus/descriptors'; in\norder to use that system parameter. When the transformer sees a system with that\ntype, it'll generate the necessary code to make your systems work.\nYou may have noticed that Res as provided by Thyseus is generic - in fact, it\nhas to be in order to work correctly! When system parameters accept generics,\nthose are passed as arguments to the parameter descriptor function.\nIt is up to you to validate that the types provided to your system parameter and\nthe arguments provided to your descriptor are correct, both at the type level\nand at runtime."
		}
	}
}
