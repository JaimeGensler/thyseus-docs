---
title: Worlds
---

import { Callout } from ':ui';

# Worlds

Worlds are the starting point for every Thyseus app. They contain your entities
and components, and are responsible for executing systems. Every world is
independent and self-contained; systems and types can be used by multiple
worlds, but data belongs to a single world. Most Thyseus applications only use a
single world, but you may use multiple.

## Creating a world

Worlds can be created with the aid of a WorldBuilder.

```ts
import { World } from 'thyseus';

const myWorldBuilder = World.new();
```

The `WorldBuilder` is responsible for registering all systems and types that
will be used in a particular World; all systems and types you wish to use in the
world **must be registered** in order to be used in a world.

Fortunately, you typically only need to worry about adding systems to your
world; when you add a system, it can (usually) handle registering the types it
uses.

```ts
import { World } from 'thyseus';
import { ComponentA, ComponentB, MyResource } from './anotherModule';

function mySystem(
	query: Query<ComponentA, With<ComponentB>>,
	resource: Res<MyResource>,
) {
	// ...
}

// This will add the system to the world,
// register components ComponentA & ComponentB
// and register the resource MyResource
const myWorldBuilder = World.new().addSystem(mySystem);
```

<Callout type="note">
	In rare cases, you may need to register some types manually - the [API
	Docs](/complete_api_docs) cover all registration methods. Also note that
	registration handles deduplicating types, so you never need to worry about
	registering types multiple times.
</Callout>

All registration methods on `WorldBuilder`s return the same `WorldBuilder` so
they can be chained:

```ts
import { World } from 'thyseus';
import { coolPlugin } from 'a-third-party-library';
import { systemA, systemB, systemC, systemD } from './someModule';

const myWorldBuilder = World.new()
	.addPlugin(coolPlugin)
	.addSystem(systemA)
	.addSystem(systemB)
	.addSystem(systemC)
	.addSystem(systemD);
```

`World.new()` also accepts some configuration, which can be found in the
[API Docs](/complete_api_docs).

## Startup Systems

Most worlds will need a system or systems that only run once and handle some
setup, such as spawning initial entities. For these, you can add "startup"
systems:

```ts
import { World } from 'thyseus';
import { spawnInitialEntitiesSystem } from './loadGameWorld';

const myWorldBuilder = World.new().addStartupSystem(spawnInitialEntitiesSystem);
```

Startup systems register types like any other system, but will only ever be
called once, when the world is built.

## Plugins

Plugins are simply functions that accept a `WorldBuilder` instance and register
systems and types on that `WorldBuilder`. If you're building a third party
library to be used with Thyseus, it's recommended that you model it as a plugin,
even if it only registers a single system! Plugins give you the flexibility to
change the implementation details of your library (e.g., reorganize into
multiple systems) without changing the external API.

You can also use plugins in your own code to group related functionality that
may be needed in multiple worlds. Thyseus exports a `definePlugin` function for
type help:

```ts
import { definePlugin } from 'thyseus';

const myPlugin = definePlugin(builder => {
	// Whatever you need to do with the builder in here!
	builder.addSystem(/* ... */);
});
```

## Constructing a World

Once you've added all your systems and registered your types, it's time to build
the world! This can be done with the `build()` method on `WorldBuilder`. This
function returns a `Promise<World>` - construction and setup is async!

```ts
import { World } from 'thyseus';

const myWorld = await World.new()
	// ...
	// Add systems, plugins, whatever you need!
	// ...
	.build();
```

<Callout type="note">
	Top-level await is a convenient way to handle the promise returned by
	`build()` - especially when starting out - but it isn't required. Handle it
	however you'd like!
</Callout>

When you call `build()`, threads will be created (if multithreading is being
used), the world will be constructed, resources will be initialized, system
parameters will be created, and startup systems will be run.

Once your world is built, you can start executing systems with
`myWorld.update()`.

```ts
import { myWorld } from './myWorldModule';

async function loop() {
	await myWorld.update();
	requestAnimationFrame(loop);
}
loop();
```

And you're using Thyseus! As mentioned above, built worlds cannot register new
types or systems, so make sure you add anything you need in the builder!
